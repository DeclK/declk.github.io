<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 面向对象</title>
      <link href="/archives/59bf225c.html"/>
      <url>/archives/59bf225c.html</url>
      
        <content type="html"><![CDATA[<h1 id="python-面向对象"><a href="#python-面向对象" class="headerlink" title="python 面向对象"></a>python 面向对象</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>什么是面向对象编程？用一段话描述面向对象的思想：</p><blockquote><p>把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派</p></blockquote><p>这一段话我在之前是看得云里雾里，这样高度的概括过于抽象。现在看过了一些代码过后，再回头看这段话才没那么迷惑</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类是对象的模板，对象是类的实例。在面向对象的世界中，一切皆为对象。下面来创建一个类</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age        <span class="token keyword">def</span> <span class="token function">introduce</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My name is %s. I'm %d."</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之前提到过 <code>__init__()</code> 方法在类中属于特殊方法，会在创建对象的时候自动调用。通过这个方法可以给对象绑定 <code>name</code> &amp; <code>age</code> 两个属性，这样在其他方法里就能够随意调用这些属性，而不需要再次传入这些参数。下面来创建 <code>Student</code> 类的对象，并使用其内部函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">student_1 <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Declan'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>student_1<span class="token punctuation">.</span>introduce<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># My name is Declan. I'm 23.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建对象，就是将类实例化，具体一点来说：给类传入一些参数，让其从模板称为了一个具体的对象。可以看到在创建的对象的代码里，并没有显式使用，也不能显式使用特殊方法 <code>__init__()</code> </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># try this</span>student_2 <span class="token operator">=</span> Student<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token string">'Declan'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样做一定是会报错的。所以正确的理解是，<code>Student(name, age)</code> 中的参数 <code>name</code> &amp; <code>age</code> 就是给 <code>__init__()</code> 的参数，并在创建对象的时候自动运行 <code>__init__()</code> 方法</p><h3 id="访问可见性问题"><a href="#访问可见性问题" class="headerlink" title="访问可见性问题"></a>访问可见性问题</h3><p>在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），在 Python 中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__private <span class="token operator">=</span> <span class="token string">'private'</span>        self<span class="token punctuation">.</span>__func<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token keyword">def</span> <span class="token function">__func</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>__private<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this function is private'</span><span class="token punctuation">)</span>test <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># private</span><span class="token comment"># this function is private</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>__private<span class="token punctuation">)</span><span class="token comment"># AttributeError: 'Test' object has no attribute '__private'</span><span class="token comment"># 直接访问被阻拦，但拐个弯还是有方法能够访问</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>_Test__private<span class="token punctuation">)</span><span class="token comment"># private</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看在类的内部调用这些私有变量和函数是没有问题的，但是想要在函数之外直接访问这些变量和函数是被禁止的。在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数 Python 程序员会遵循一种命名惯例就是让属性名以单下划线开头如 <code>_name</code>，来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重</p><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是 self，当然也可以叫其它名字，下面看看这个 self 到底代表了什么</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>SELF<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>SELF<span class="token punctuation">.</span>__class__<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">pointer_self</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>test <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token punctuation">)</span>test<span class="token punctuation">.</span>pointer_self<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># &lt;class '__main__.Test'&gt;</span><span class="token comment"># &lt;__main__.Test object at 0x000001B64F611040&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果一种语言不支持继承，类就没有什么意义。子类会继承父类（也叫基类）的属性和方法，而且还可以定义自己的属性和方法，所以子类比父类拥有更多的能力，下面看一个简短的代码，理解继承机制的逻辑</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这是之前写的学生类</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age        self<span class="token punctuation">.</span>log <span class="token operator">=</span> <span class="token string">'this is a student'</span>        <span class="token keyword">def</span> <span class="token function">introduce</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My name is %s. I'm %d."</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 现在建立一个本科生类</span><span class="token keyword">class</span> <span class="token class-name">Undergraduate</span><span class="token punctuation">(</span>Student<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 在子类中调用父类的方法</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>grade <span class="token operator">=</span> grade    <span class="token keyword">def</span> <span class="token function">which_grade</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'My grade is %d.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>grade<span class="token punctuation">)</span>        <span class="token comment"># 在多态的时候取消注释</span>    <span class="token comment"># def introduce(self):</span>    <span class="token comment">#     print("Hello! My name is %s. I'm %d." % (self.name, self.age))</span>student_1 <span class="token operator">=</span> Undergraduate<span class="token punctuation">(</span><span class="token string">'Declan'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>student_1<span class="token punctuation">.</span>which_grade<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># My grade is 1.</span><span class="token comment"># 子类实例直接使用父类的属性和方法</span><span class="token keyword">print</span><span class="token punctuation">(</span>student_1<span class="token punctuation">.</span>log<span class="token punctuation">)</span>student_1<span class="token punctuation">.</span>introduce<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># this is a student</span><span class="token comment"># My name is Declan. I'm 18.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点的几个逻辑：</p><ol><li>声明父类，在定义的类名后传入父类名即可，如 <code>class Undergraduate(Student)</code></li><li>调用父类，通过 <code>super()</code> 函数调用父类中的属性、方法，如果是 python 2.x 的话需要使用 <code>super(子类名, self)</code> 调用</li><li>实例使用父类，子类实例可以直接使用父类中的属性、方法</li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override），父类的方法可以被多个子类进行重写得到多个不同的实现版本，这个就是多态（poly-morphism）</p><p>把上一节中关于多态的代码取消注释，再调用 <code>introduce()</code> 方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">student_1<span class="token punctuation">.</span>introduce<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Hello! My name is Declan. I'm 18.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发现比之前父类的 <code>introduce()</code> 多打印了 <code>Hello!</code> 重写成功！ </p><h2 id="补充：类的特殊方法"><a href="#补充：类的特殊方法" class="headerlink" title="补充：类的特殊方法"></a>补充：类的特殊方法</h2><p>这些类的特殊方法也叫魔术方法，在特殊条件下被调用，下面列举一些</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span> <span class="token operator">**</span>__init__ <span class="token punctuation">:</span><span class="token operator">**</span> 构造函数，在生成对象时调用<span class="token operator">-</span> <span class="token operator">**</span>__del__ <span class="token punctuation">:</span><span class="token operator">**</span> 析构函数，释放对象时使用<span class="token operator">-</span> <span class="token operator">**</span>__repr__ <span class="token punctuation">:</span><span class="token operator">**</span> 打印对象时调用<span class="token operator">-</span> <span class="token operator">**</span>__setitem__ <span class="token punctuation">:</span><span class="token operator">**</span> 按照索引赋值<span class="token operator">-</span> <span class="token operator">**</span>__getitem__<span class="token punctuation">:</span><span class="token operator">**</span> 按照索引获取值<span class="token operator">-</span> <span class="token operator">**</span>__len__<span class="token punctuation">:</span><span class="token operator">**</span> 获得长度<span class="token operator">-</span> <span class="token operator">**</span>__cmp__<span class="token punctuation">:</span><span class="token operator">**</span> 比较运算<span class="token operator">-</span> <span class="token operator">**</span>__call__<span class="token punctuation">:</span><span class="token operator">**</span> 让对象变为可调用对象<span class="token comment"># 下面的魔术方法可以进行算符重载</span><span class="token operator">-</span> <span class="token operator">**</span>__add__<span class="token punctuation">:</span><span class="token operator">**</span> 加运算<span class="token operator">-</span> <span class="token operator">**</span>__sub__<span class="token punctuation">:</span><span class="token operator">**</span> 减运算<span class="token operator">-</span> <span class="token operator">**</span>__mul__<span class="token punctuation">:</span><span class="token operator">**</span> 乘运算<span class="token operator">-</span> <span class="token operator">**</span>__truediv__<span class="token punctuation">:</span><span class="token operator">**</span> 除运算<span class="token operator">-</span> <span class="token operator">**</span>__mod__<span class="token punctuation">:</span><span class="token operator">**</span> 求余运算<span class="token operator">-</span> <span class="token operator">**</span>__pow__<span class="token punctuation">:</span><span class="token operator">**</span> 乘方<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实验一下 <code>__repr__, __call__</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>age <span class="token operator">=</span> age    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"My name is {}. I'm {}."</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grade<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'grade {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>grade<span class="token punctuation">)</span>name <span class="token operator">=</span> <span class="token string">'Declan'</span>age <span class="token operator">=</span> <span class="token number">23</span>stu <span class="token operator">=</span> Student<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token comment"># My name is Declan. I'm 23.</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># grade 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="补充：装饰器"><a href="#补充：装饰器" class="headerlink" title="补充：装饰器"></a>补充：装饰器</h2><p>参考 <a href="https://www.cnblogs.com/auguse/articles/9922257.html">博客</a> 进行整理。装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能。由于在学习 mmdetection 中发现 <code>registry</code> 类的实现就需要装饰器的帮忙，所以接下来将“花费”一些篇幅来了解装饰器的内部逻辑</p><h3 id="装饰器基本原理"><a href="#装饰器基本原理" class="headerlink" title="装饰器基本原理"></a>装饰器基本原理</h3><p>下面先看看不用 python 装饰器，怎样实现其类似的功能</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 原函数</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My name is {}, and I'm {}."</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 定义一个装饰器来包装原函数</span><span class="token keyword">def</span> <span class="token function">decorate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This is my introduction.'</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token comment"># 返回新的函数名</span>    <span class="token keyword">return</span> wrap<span class="token comment"># 将原函数包装，并将原函数指向装饰后的函数</span>test  <span class="token operator">=</span> decorate<span class="token punctuation">(</span>test<span class="token punctuation">)</span>name <span class="token operator">=</span> <span class="token string">'Declan'</span>age <span class="token operator">=</span> <span class="token number">23</span>test<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token comment"># This is my introduction.</span><span class="token comment"># My name is Declan, and I'm 23.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就实现了一个简单的装饰器，该装饰器的功能就是在原函数之前打印一句话 <code>This is my introduction</code></p><p>python 使用 <code>@</code> 关键字来实现装饰器，具体来说 <code>@</code> 关键字实现的是上面代码中的注释“将原函数包装，并将原函数指向装饰后的函数”。将之前的装饰器，用 <code>@</code> 重新实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义一个装饰器来包装原函数</span><span class="token keyword">def</span> <span class="token function">decorate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This is my introduction.'</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token comment"># 返回新的函数名</span>    <span class="token keyword">return</span> wrap<span class="token comment"># 原函数+装饰器</span><span class="token decorator annotation punctuation">@decorate</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My name is {}, and I'm {}."</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># test  = decortate(test)</span>name <span class="token operator">=</span> <span class="token string">'Declan'</span>age <span class="token operator">=</span> <span class="token number">23</span>test<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token comment"># This is my introduction.</span><span class="token comment"># My name is Declan, and I'm 23</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># &lt;class 'function'&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，就是在原函数之前加上 <code>@decorate</code> 就实现了对原函数的装饰，替代了 <code>test  = decorate(test)</code> 这一步。换句话说 <code>@</code> 关键字将下一行的函数/类，作为参数传给了 <code>decorate</code> 函数，这就是装饰器的关键之一。之前的装饰器只接受了原函数 <code>test</code> 作为参数，那如果想要实现传入多个参数，例如 <code>@decorate(*args)</code> 应该怎么办呢？接下来实现一个带参数的装饰器</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">'Declan'</span>age <span class="token operator">=</span> <span class="token number">23</span><span class="token keyword">def</span> <span class="token function">param_decorate</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"It's running without test()"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This is a introduction.'</span><span class="token punctuation">)</span>        func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    <span class="token keyword">return</span> wrap<span class="token decorator annotation punctuation">@param_decorate</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My name is {}, and I'm {}."</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 使没有运行 test() 以上代码能够输出内容</span><span class="token comment"># It's running without test()</span><span class="token comment"># This is a introduction.</span><span class="token comment"># My name is Declan, and I'm 23</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># &lt;class 'NoneType'&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用以上代码会发现，即使没有运行 <code>test</code> 函数也输出了内容。这是因为给装饰器添加参数过后，那么 <code>@</code> 后跟随的就是一个执行函数，python 就会真实地执行该函数的内容。执行 <code>param_decorate</code> 函数返回的是一个函数名 <code>wrap</code>，那么此时相当于 <code>@wrap</code>，也即 <code>test</code> 函数会被作为参数传入到 <code>wrap()</code> 函数当中，此时 <code>test  = wrap(test)</code> 的返回对象是 <code>NoneType</code>，而之前 <code>test = decorate(test)</code> 返回对象是一个函数名</p><p>还有一个方法来学习装饰器的内部逻辑，就是直接对代码 debug，一步步看程序是如何运行的</p><h3 id="python-内置装饰器"><a href="#python-内置装饰器" class="headerlink" title="python 内置装饰器"></a>python 内置装饰器</h3><p>内置的装饰器和普通的装饰器原理是一样的，只不过一般用于类的方法当中，让类变得更灵活</p><h4 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h4><p>参考 <a href="https://www.runoob.com/python/python-func-property.html">菜鸟教程</a> <a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030547069856">廖雪峰教程 </a>进行整理。<code>@property</code> 能够用于管理类的私有属性，方便读取属性、修改属性。下面看看如何使用该装饰器</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">get_the_score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""I'm the 'score' property."""</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_score     <span class="token decorator annotation punctuation">@get_the_score<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">score</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_score <span class="token operator">=</span> value     <span class="token decorator annotation punctuation">@get_the_score<span class="token punctuation">.</span>deleter</span>    <span class="token keyword">def</span> <span class="token function">score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>_scorestudent <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># setter不仅可以更改属性值，也可以创建该属性</span>student<span class="token punctuation">.</span>get_the_score <span class="token operator">=</span> <span class="token number">60</span><span class="token comment"># 查看属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span>get_the_score<span class="token punctuation">)</span><span class="token comment"># 60</span><span class="token comment"># 也使用原属性名称更改和访问</span>student<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">print</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token comment"># 100</span><span class="token comment"># 删除属性</span><span class="token comment"># del student.score</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@property</code> 的实现比较复杂，我感觉我是真没理解，这里直接引用一下廖雪峰教程中的话：</p><blockquote><p>把一个 <code>get_the_score</code> 方法变成属性，只需要加上 <code>@property</code> 就可以了。此时，<code>@property</code>本身又创建了另一个装饰器 <code>@get_the_score.setter</code>，负责把一个 setter 方法变成属性赋值，于是，我们就拥有一个可控的属性操作</p></blockquote><p>我自己理解，如果需要只读属性，则只使用 <code>@property</code> 装饰器就可以了，如果还需要对属性进行进一步操控则加上其他 <code>setter, deleter</code> 装饰器</p><p>而且，如果使用了 <code>property</code> 装饰器，必须要使用单下划线变量，不然会报错，具体原因参考 <a href="https://zhuanlan.zhihu.com/p/53469919">知乎链接</a></p><h4 id="classmethod"><a href="#classmethod" class="headerlink" title="@classmethod"></a>@classmethod</h4><p>参考 <a href="https://zhuanlan.zhihu.com/p/35643573">知乎链接</a> 进行整理，<code>classmethod</code> 又被叫做类方法。<code>__init__()</code> 作为类的构造函数，能够在生成对象时调用，但如果想要使用其他构造函数时，可以使用<code>@classmethod</code> 实现，下面看如何使用类方法创建一个对象（为方便，把静态方法 <code>staticmethod</code> 的代码也写在这儿）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>year <span class="token operator">=</span> year        self<span class="token punctuation">.</span>month <span class="token operator">=</span> month        self<span class="token punctuation">.</span>day <span class="token operator">=</span> day        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{}年{}月{}日'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>year<span class="token punctuation">,</span> self<span class="token punctuation">.</span>month<span class="token punctuation">,</span> self<span class="token punctuation">.</span>day<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@classmethod</span>    <span class="token keyword">def</span> <span class="token function">create_from_string</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>        year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span>string<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">is_leap</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> year <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">elif</span> year <span class="token operator">%</span> <span class="token number">400</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment"># 普通构造</span>date <span class="token operator">=</span> Date<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token comment"># 2020年7月31日</span><span class="token comment"># 通过类方法构造</span>date <span class="token operator">=</span> Date<span class="token punctuation">.</span>create_from_string<span class="token punctuation">(</span><span class="token string">'2020-7-31'</span><span class="token punctuation">)</span><span class="token comment"># 2020年7月31日</span><span class="token comment"># 使用静态方法</span><span class="token keyword">print</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span>is_leap<span class="token punctuation">(</span><span class="token number">1900</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点需要注意的是类方法的第一个参数，其表示调用当前的类名，默认名称为 <code>cls</code>，有点类似于 <code>self</code> 表示类的实例。那么类方法最后的返回值 <code>return cls(year, month, day)</code> 也就不难理解了，相当于 <code>return Data(year, month, day)</code> 重新创建了对象</p><p>类方法能够在不改变原本构造函数的情况下，给类的构造方法增加一些额外功能，例如对于传入参数做一些不同的处理等等</p><h4 id="staticmethod"><a href="#staticmethod" class="headerlink" title="@staticmethod"></a>@staticmethod</h4><p>参考 <a href="https://www.cnblogs.com/Meanwey/p/9788713.html">博客</a> 的说法：<code>@staticmethod</code> 静态方法只是名义上归属类管理，但是不能使用类变量和实例变量，是类的工具包。因为该函数不传入self或者cls，所以不能访问类属性和实例属性。静态方法的一个好处是，不用创建类的实例也能够调用该方法，具体调用方法参考上面代码</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> python </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 拓展</title>
      <link href="/archives/c19cb72c.html"/>
      <url>/archives/c19cb72c.html</url>
      
        <content type="html"><![CDATA[<h1 id="python-拓展"><a href="#python-拓展" class="headerlink" title="python 拓展"></a>python 拓展</h1><h2 id="format输出"><a href="#format输出" class="headerlink" title="format输出"></a>format输出</h2><p>这里总结一下 format 输出的形式，主要以 <code>{position:format}</code> 形式对变量进行引用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">'Declan'</span>age <span class="token operator">=</span> <span class="token number">23</span><span class="token comment"># 按照顺序引用</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{0} {1} {0}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Declan 23 Declan</span><span class="token comment"># 按照关键字引用</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{name} {age}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token operator">=</span>name<span class="token punctuation">,</span> age<span class="token operator">=</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Declan 23</span><span class="token comment"># 数字格式化</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{:.2f}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 23.00</span><span class="token comment"># 输出左右对齐</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{:0&gt;10d}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 向右对齐，默认宽度为10，不够以0补位</span><span class="token comment"># 0000000023</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{:x&lt;10b}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment"># 向左对齐，默认宽度为10，不够以x补位</span><span class="token comment"># 10111xxxxx</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。<strong>注意：</strong>使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法</p><p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)，更多参数查询  <a href="https://www.runoob.com/python/file-methods.html">菜鸟教程</a>。现在介绍一下常用的 <code>mode</code> 参数：</p><ol><li><code>r</code>，只读模式</li><li><code>w</code>，写入模式，会擦除文件中之前的内容，重新写入。如果没有文件会自动创建</li><li><code>a</code>，附加模式，会在文件末尾加入新内容</li><li><code>r+</code>，读写模式，指针位于文件开头</li></ol><p>下面介绍操作文件的基本功能：读和写。我们先在 python 脚本所在文件夹新建一个文本文档 <code>test.txt</code> 内容为 <code>a, b, c</code></p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token comment"># 使用 read(size) 输出</span><span class="token comment"># 如果不传入输出字符数量，则全部输出</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># a, b, c</span><span class="token comment"># 读完文件过后需要移动指针到文件开头才能重新再读一遍</span><span class="token comment"># 使用 seek(offset)，默认0位置从文件开头算起</span>f<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># 使用 readlines() 逐行输出</span><span class="token comment"># 该方法返回值是由每一行内容组成的一个列表</span><span class="token keyword">for</span> i <span class="token keyword">in</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment"># a, b, c</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token comment"># 使用 write(str) 在指针处写入内容</span>f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\nadd something'</span><span class="token punctuation">)</span><span class="token comment"># a, b, c</span><span class="token comment"># add something</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要写入中文，建议设置编码为 utf-8，<code>open(filename, mode, encoding='utf-8')</code></p><h3 id="with-关键字"><a href="#with-关键字" class="headerlink" title="with 关键字"></a>with 关键字</h3><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。只需要该对象定义了 <code>__enter__ &amp; __exit__</code> 魔术方法，关键字 with 就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment"># statement</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="os-amp-system-模块"><a href="#os-amp-system-模块" class="headerlink" title="os &amp; system 模块"></a>os &amp; system 模块</h2><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。关于 os 模块更多操作可以查询 <a href="https://www.runoob.com/python3/python3-os-file-methods.html">菜鸟教程</a>，这里列举一些常用的部分。由于返回的这些路径多为字符串类型，所以字符串的操作在这里也会经常使用</p><h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment"># 操作系统名称</span><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">)</span>   <span class="token comment"># 环境变量，返回一个“字典”</span><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>sep<span class="token punctuation">,</span> os<span class="token punctuation">.</span>pathsep<span class="token punctuation">)</span>   <span class="token comment"># 路径分割符号，windows 为 \ ;</span><span class="token comment"># 查看一下 PATH 环境变量</span><span class="token comment"># PATH一般为系统指定可执行文件的搜索路径</span>PATH <span class="token operator">=</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'PATH'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token keyword">for</span> path <span class="token keyword">in</span> PATH<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> ospath <span class="token operator">=</span> <span class="token string">'.'</span>  <span class="token comment"># 当前文件夹</span>os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token string">'folder'</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">'folder\subfolder'</span><span class="token punctuation">)</span>os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>path<span class="token punctuation">)</span>   <span class="token comment"># 删除文件</span>os<span class="token punctuation">.</span>removedirs<span class="token punctuation">(</span>path<span class="token punctuation">)</span>   <span class="token comment"># 删除空文件夹</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token comment"># 返回文件列表</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 返回当前路径</span><span class="token comment"># os.path 是一个常用模块，重点介绍</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>path<span class="token punctuation">)</span>   <span class="token comment"># 返回绝对路径</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>path<span class="token punctuation">)</span>   <span class="token comment"># 返回路径的 dirname</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>split<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token comment"># 把路径分割成 dirname 和 basename，返回一个元组</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>path<span class="token punctuation">)</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token comment"># 将多个名称合成为一个路径名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>sys 即 system，该模块提供了一些接口，用于访问 Python 解释器自身使用和维护的变量。下面列举一些常用成员</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> syssys<span class="token punctuation">.</span>version <span class="token comment"># 版本号</span>sys<span class="token punctuation">.</span>path    <span class="token comment"># python 解释器搜索路径</span>sys<span class="token punctuation">.</span>argv    <span class="token comment"># 传入当前 python 文件的参数列表</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># 退出状态码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p>当 Python 脚本发生异常时我们需要捕获处理它，否则程序会终止执行</p><h3 id="try相关"><a href="#try相关" class="headerlink" title="try相关"></a>try相关</h3><p>异常处理的方法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    statement<span class="token keyword">except</span> Exception<span class="token punctuation">:</span>    <span class="token comment"># 发生异常时执行的代码</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Something Wrong!'</span><span class="token punctuation">)</span>    statement<span class="token comment"># 可以有多个 exception 表示面对不同异常的处理</span><span class="token keyword">except</span> Excepthion_2<span class="token punctuation">:</span>    <span class="token comment"># 发生异常时执行的代码</span>    statement<span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token comment"># 没有异常时执行的代码</span>    statement<span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token comment"># 无论有没有异常都会执行的代码</span>    statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>Python 使用 raise 语句抛出一个指定的异常。更多 python 内置异常查看 <a href="https://www.runoob.com/python/python-exceptions.html">菜鸟教程</a></p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。其基本语法为</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">assert</span> expression <span class="token punctuation">[</span><span class="token punctuation">,</span> arguments<span class="token punctuation">]</span><span class="token comment"># 与以下代码等价</span><span class="token keyword">if</span> <span class="token keyword">not</span> expression<span class="token punctuation">:</span>    <span class="token keyword">raise</span> AssertionError<span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后的参数为抛出异常的补充信息，也可以不用加。下面举一个例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">assert</span> <span class="token number">1</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Somenthing Wrong!'</span><span class="token comment"># 以下为异常</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"d:/..."</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>    <span class="token keyword">assert</span> <span class="token number">1</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Somenthing Wrong!'</span>AssertionError<span class="token punctuation">:</span> Somenthing Wrong!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><h3 id="Argparse-模块"><a href="#Argparse-模块" class="headerlink" title="Argparse 模块"></a>Argparse 模块</h3><h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><h3 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python 爬虫"></a>Python 爬虫</h3>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> python </tag>
            
            <tag> 拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据结构</title>
      <link href="/archives/760ade0a.html"/>
      <url>/archives/760ade0a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python-String-amp-Data-Structure"><a href="#Python-String-amp-Data-Structure" class="headerlink" title="Python String &amp; Data Structure"></a>Python String &amp; Data Structure</h1><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>python 用单引号 <code>''</code> 或者双引号 <code>""</code> 来表示字符串，三引号 <code>'''</code> 允许跨多行的字符串</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s1 <span class="token operator">=</span> <span class="token string">'hello, world!'</span>s2 <span class="token operator">=</span> <span class="token string">"hello, world!"</span><span class="token comment"># 以三个双引号或单引号开头的字符串可以折行</span>s3 <span class="token operator">=</span> <span class="token triple-quoted-string string">"""hello, world!"""</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s3<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串中可以使用反斜杠 <code>\</code> 表示转义，如 <code>\n, \t</code> 等转义字符，如果希望输入原字符串可在引号前加 r 字母</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s1 <span class="token operator">=</span> <span class="token string">'\n\\hello, world!\\\n'</span>s2 <span class="token operator">=</span> <span class="token string">r'\n\\hello, world!\\\n'</span><span class="token keyword">print</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>字符串接受 <code>+, *, [:], in</code> 等运算，对字符串内容进行合并、重复、截取、成员运算</p><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>当字符串中需要表示变量时，格式化表示将会非常有用，基本用法如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">num<span class="token punctuation">,</span> pai <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.1415926</span>s <span class="token operator">=</span> <span class="token string">'here is a number %d, and pai is %.2f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span> pai<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基本逻辑就是，一个萝卜一个坑，想要在字符串中插入变量，就在需要插入的地方用相应的符号替代，然后在字符串后用 <code>%</code> 指明变量</p><p>这里列几个常用的替代符号：<code>%d, %f, %s, %e</code>，最后一个 <code>%e</code> 表示科学计数</p><h3 id="字符串内建函数"><a href="#字符串内建函数" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h3><p>字符串自带了很多方便的方法，这里列举几个常用的，string 代表某个字符串</p><ol><li><p><code>sting.count(str)</code>，字符串中有多少个 str</p></li><li><p><code>string.find(str)</code>，str 在字符串中的哪个位置，如不存在返回-1</p></li><li><p><code>string.format(*args, **kwargs)</code>，<strong>增强版格式化方法，非常推荐使用该函数来格式化字符串</strong>，参考 <a href="https://www.runoob.com/python/att-string-format.html">菜鸟教程</a></p></li><li><p><code>string.split(str)</code>，<strong>按照 str 分隔字符串，返回一个列表</strong></p></li><li><p><code>string.replace(str1, str2)</code>，将 str1 替换为 str2</p></li></ol><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h2><p>列表是最基本的数据结构，可以顺序存储不同的对象。在 python 中创建列表：</p><ol><li>直接赋值 <code>LIST = []</code></li><li>类型转换 <code>list(tuple)</code></li></ol><h3 id="列表运算"><a href="#列表运算" class="headerlink" title="列表运算"></a>列表运算</h3><p>列表也接受：<code>+, *, [:], in</code> 等运算符</p><h3 id="python-内置函数操作列表"><a href="#python-内置函数操作列表" class="headerlink" title="python 内置函数操作列表"></a>python 内置函数操作列表</h3><ol><li><code>len(list)</code></li><li><code>max(list)</code> &amp; <code>min(list)</code></li><li><code>for i in list</code> &amp; <code>for index, value in enumerate(list)</code>，对列表进行循环遍历</li></ol><h3 id="列表内建函数"><a href="#列表内建函数" class="headerlink" title="列表内建函数"></a>列表内建函数</h3><ol><li><code>list.append(obj)</code> &amp; <code>list.insert(index, obj)</code></li><li><code>list.remove(obj)</code> &amp; <code>list.pop()</code></li><li><code>list.sort(reverse=False)</code>，将列表按照上升值排列，返回 None</li><li><code>list.copy()</code></li></ol><h2 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple 元组"></a>Tuple 元组</h2><p>元组和列表类似，也是线性表的一种，不过在元组建立过后，其成员是不能够被修改的，增加和删除成员也是不支持的，在 python 中创建元组：</p><ol><li>直接赋值 <code>TUPLE = (1,)</code></li><li>类型转换 <code>tuple(list)</code></li></ol><h3 id="元组运算"><a href="#元组运算" class="headerlink" title="元组运算"></a>元组运算</h3><p>元组支持 <code>+, *, [:], in</code> 等运算符，但注意，由于元组成员不能被修改的性质，所以不能够对索引值进行新的赋值。虽然不能增加成员，但是仍可以使用 <code>+</code> 运算，将两个元组合并</p><h3 id="python-内置函数操作元组"><a href="#python-内置函数操作元组" class="headerlink" title="python 内置函数操作元组"></a>python 内置函数操作元组</h3><p>在列表当中能用的操作也能用作元组，毕竟元组可以看作不可修改成员的列表</p><h3 id="元组内建函数"><a href="#元组内建函数" class="headerlink" title="元组内建函数"></a>元组内建函数</h3><p>元组的内建函数就不如列表的丰富了，可以说元组有的，列表都有。下面列举两个</p><ol><li><p><code>tuple.count(obj)</code></p></li><li><p><code>tuple.index(obj)</code>，返回 obj 在元组中的索引数，若元组中不存在 obj 则报错</p></li></ol><p>最后提一句，为什么有了列表还需要有元组这样的数据类型呢？部分原因是元组可以用于保护一些数据，让其不被修改，并且创建元组在时间和空间上的代价更小</p><h2 id="Dict-字典"><a href="#Dict-字典" class="headerlink" title="Dict 字典"></a>Dict 字典</h2><p>字典也是一种可变容器，其不是通过 index 索引获得容器内的对象，而是通过 key: value 对，将 key 映射到其对应的 value。换句话说就是通过 key 来获得容器内的对象。很明显这样的映射性质需要 key 是唯一的，同时 python 也要求 key 是不可变的，如数字，字符串，元组。创建字典的方式：</p><ol><li><p>直接赋值 <code>DICT = {key_1：value_1}</code></p></li><li><p>通过内置函数 <code>dict()</code> 创建：</p><ul><li><p><code>dict(**kwargs)</code>，传入 key=value 对，例如 <code>DICT = dict(a=1, b=2)</code>，注意这里 key 不用转化为字符串形式</p></li><li><p><code>dict(iterable, **kwargs)</code>，传入可迭代对象，其中可迭代对象中的成员必须为二元元组，同时也可任意传入 key=value 对，下面举一个例子</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">ITER <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment"># ITER 也可以通过 python 内置函数 zip() 生成</span><span class="token comment"># ITER = zip(['a', 'b'], [1, 2])</span>DICT <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>ITER<span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.fromkeys(iterable, value)</code>，传入可迭代对象，比如列表、元组都可以，将这些顺序表的成员作为 key 创建字典，并且所有的 value 都统一初始化</li></ul></li></ol><h3 id="字典运算"><a href="#字典运算" class="headerlink" title="字典运算"></a>字典运算</h3><p>字典支持 <code>[], in</code> 运算，显然 <code>+, *</code> 运算对于字典是没有意义的。而 <code>[]</code> 运算区别于列表和元组，索引值不是数字而是 key</p><h3 id="python-内置函数操作字典"><a href="#python-内置函数操作字典" class="headerlink" title="python 内置函数操作字典"></a>python 内置函数操作字典</h3><ol><li><p><code>len(dict)</code></p></li><li><p><code>for i in dict</code>，注意这样形式的循环只会对字典中的 key 进行循环遍历。如果想要同时对 key 和 value 循环遍历则需要调用字典内建函数 <code>dict.items()</code> 返回可遍历的 (key, value) 元组数组</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">DICT <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> DICT<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment"># result: a b</span><span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> DICT<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s:%d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># result: a:1 b:2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="字典内建函数"><a href="#字典内建函数" class="headerlink" title="字典内建函数"></a>字典内建函数</h3><ol><li><code>dict.get(key, default=None)</code>，返回指定键的值，如果 key 值不在字典中则自动添加 key 并返回 default 值作为其 value。这既是一种获取 value 的方法，也是创建新 key 的方法。比较类似的，如果字典中不存在某个 key，那么使用 <code>dict[key] = value</code> 也会自动在字典中创建 key, value 对</li><li><code>dict.items()</code> 返回可遍历的 (key, value) 元组组成的列表</li><li><p><code>dict.keys()</code> &amp; <code>dict.values()</code> 返回 key/value 列表</p></li><li><p><code>dict.pop(key, default)</code> &amp; <code>dict.clear()</code> 前者删除 key 值，并返回该 key 对应 value，若不存在该 key 则返回 default。后者清空字典所有内容</p></li><li><code>dict.update(dict_new)</code> 将新字典里的 (key, value) 更新到本字典中</li><li><code>dict.copy()</code></li></ol><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>集合是一个无序的不重复元素序列，且元素性质是不可变的，如数字，字符串，元组。创建集合有如下方法：</p><ol><li><p>直接赋值 <code>SET = {1, 2, 3}</code> 这里必须有元素，如果没有则会创建一个字典</p></li><li><p>类型转换 <code>set(iterable)</code>，传入可迭代对象，可以是列表、元组，也可以不传参数以创建空集合</p></li></ol><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>集合运算相比于前面的数据结构就要更多了，除了基础的 <code>[], in</code> 这样的索引和成员运算，还有 <code>&amp;, |, -, ^</code> 交集、并集、差集、异或（对称差集）</p><h3 id="python-内置函数操作集合"><a href="#python-内置函数操作集合" class="headerlink" title="python 内置函数操作集合"></a>python 内置函数操作集合</h3><p>在列表当中能用的操作也能用作集合，毕竟集合可以粗略看作要求元素唯一的列表</p><h3 id="集合内建函数"><a href="#集合内建函数" class="headerlink" title="集合内建函数"></a>集合内建函数</h3><ol><li><code>set.add()</code></li><li><code>set.remove(obj)</code> &amp; <code>set.clear()</code> 前者删除指定元素，后者清空所有</li><li><code>set.issubset(set_new)</code> &amp; <code>set.issuperset(set_new)</code> &amp; <code>set.isdisjoint(set_new)</code> 判断是否是集合的子集、超集，以及是否是不相交的</li></ol><h2 id="补充：迭代器，生成式，生成器"><a href="#补充：迭代器，生成式，生成器" class="headerlink" title="补充：迭代器，生成式，生成器"></a>补充：迭代器，生成式，生成器</h2><p>这一部分将会涉及到部分面向对象的内容，以及 python 的特殊方法。之前就是因为缺少这两部分的内容的了解，一直对迭代器、生成器不理解，现在进行整理。参考资料：<a href="https://www.runoob.com/python3/python3-iterator-generator.html">迭代器与生成器</a> <a href="https://www.runoob.com/w3cnote/python-yield-used-analysis.html">浅析 yield</a> </p><h3 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator 迭代器"></a>iterator 迭代器</h3><p>其实在之前就已经见到了迭代器了，列表、元组、字典这些数据结构都能够在 for-in 循环的时候自动生成迭代器对象。在一个类中如何实现迭代器对象？python 提供了特殊方法 <code>__iter__()</code> 和 <code>__next__()</code> 实现创造迭代器对象，当类中有 <code>__iter__()</code> 方法时，就意味着这个类的实例不是一个普通的对象，而是一个迭代器对象</p><p>这里提一下 python 类中 <code>__function__()</code> 形式的函数被成为称为特殊函数，在特定条件发生时运行，而 <code>__iter__()</code> 和 <code>__next__()</code> 则会在 for-in 循环中被调用。下面通过迭代器实现一个简单 <code>ListDemo</code> 了解其内部逻辑</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListDemo</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>args <span class="token operator">=</span> args        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 函数内可以做一些初始化操作</span>        self<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 最后必须返回迭代器对象本身</span>        <span class="token keyword">return</span> self    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>index <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>            result <span class="token operator">=</span> self<span class="token punctuation">.</span>args<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>index <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">return</span> result        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 循环结束的标志</span>            <span class="token keyword">raise</span> StopIteration<span class="token comment"># 运行一下</span>LIST <span class="token operator">=</span>  ListDemo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> LIST<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个迭代器在循环中到底在怎么运行呢？首先 <code>ListDemo</code> 先运行了 <code>__iter__()</code> 进行了初始化，返回迭代器对象本身。在循环当中， <code>ListDemo</code> 类在重复调用 <code>__next__()</code> 函数，并返回结果给 <code>i</code>，最后遇到 <code>StopIteration</code> 结束循环</p><p>python 还有内置函数 <code>iter()</code>  &amp; <code>next()</code> 用于直接调用 <code>__iter__()</code> &amp; <code>__next__()</code> 而不需要遇到循环才触发</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">LIST <span class="token operator">=</span>  ListDemo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>iterator <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>LIST<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>iterator<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="generator-生成器"><a href="#generator-生成器" class="headerlink" title="generator 生成器"></a>generator 生成器</h3><p>如果说迭代器是定义在类当中的，那么生成器就是可以直接定义在普通函数中的迭代器。通过 <code>yield</code> 关键字能够将普通函数变为生成器，它将实现之前的  <code>__iter__()</code> 和 <code>__next__()</code> 功能。每次遇到 yield 时函数会暂停并保存当前所有的运行信息，并返回一个 <code>yield</code> 的值, 并在下一次执行 next() 方法时从当前 <code>yield</code> 位置继续运行。下面实现一个斐波那契数列函数，来进一步理解其内部逻辑</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>    count <span class="token operator">=</span> <span class="token number">0</span>     <span class="token keyword">while</span> count <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>        <span class="token keyword">yield</span> a        a_ <span class="token operator">=</span> a        a <span class="token operator">=</span> b        b <span class="token operator">=</span> a_ <span class="token operator">+</span> b        count <span class="token operator">+=</span> <span class="token number">1</span>iterator <span class="token operator">=</span> fibonacci<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> iterator<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类比一下类中的迭代器，能够更快速的理解。通过 <code>yield</code> 声明这是一个生成器，这样会在遇到 for-in 循环的时候不断地调用 next() 方法并返回 <code>yield</code> 值 <code>a</code> 赋给 <code>i</code>。区别于类中的 <code>__next__()</code>  方法是重复 <code>__next__()</code> 函数内的代码，生成器运行 <code>next()</code> 函数，则会从当前 <code>yield</code> 处继续运行，直到碰到下一个 <code>yield</code> </p><h3 id="生成式"><a href="#生成式" class="headerlink" title="生成式"></a>生成式</h3><p>生成式是生成器的一个简单应用，可以用于生成列表、字典</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 使用生成式创建列表和字典</span>f <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>f <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">+</span> y <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token string">'ABCDE'</span> <span class="token keyword">for</span> y <span class="token keyword">in</span> <span class="token string">'1234567'</span><span class="token punctuation">]</span>f <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment"># 生成式本质上是一个生成器</span>f <span class="token operator">=</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> f<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基础</title>
      <link href="/archives/2bc936a0.html"/>
      <url>/archives/2bc936a0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Basic"><a href="#Python-Basic" class="headerlink" title="Python Basic"></a>Python Basic</h1><p>在进行深度学习的实践中，越发感觉到自己的 python 理论不足，想要重新快速整理一下 python，建立一个比较完整但不细致的框架供自己之后复习。整理资源来自于 <a href="https://github.com/jackfrued/Python-100-Days">python 100 days</a> 和 <a href="https://www.runoob.com/python3/python3-tutorial.html">菜鸟教程</a> </p><h2 id="什么是-python"><a href="#什么是-python" class="headerlink" title="什么是 python?"></a>什么是 python?</h2><p>一种编程语言，以缩进分块，有着活跃的社区和丰富的三方库，在人工智能、网络爬虫、自动运维、Web开发等领域都有广泛应用</p><p>在我的狭隘理解当中 python = python.exe。当我在使用 anaconda 时，会有不同的环境，一般每一个环境都有自己的 python.exe，如果我想要运行一个 python 脚本，那么需要选择一个 python.exe/解释器 /interpreter 来执行这个脚本</p><h2 id="安装-python"><a href="#安装-python" class="headerlink" title="安装 python"></a>安装 python</h2><p>强烈建议直接安装 anaconda，简称 conda。这是一个流行的包管理工具，其管理奥义就是创建”环境“。环境中可以下载包，管理包，且每个环境都可以安装自己的 python 解释器。这就意味着如果你想要使用不同版本 python 解释器，conda 可以做到，只需要创建多个 conda 环境，想用哪个版本就切到哪个版本的 conda 环境，同时不同的环境可以下载不同的包，实现不一样的功能</p><h2 id="python-开发工具"><a href="#python-开发工具" class="headerlink" title="python 开发工具"></a>python 开发工具</h2><ol><li>python.exe，直接双击打开就可以开始写 python 代码了，最原生的交互式开发工具，懂我意思？</li><li>ipython，比原生开发工具好一点</li><li>pycharm，专业软件，非常好用</li><li>vscode，宇宙第一开发工具，懂？</li></ol><h2 id="变量与类型"><a href="#变量与类型" class="headerlink" title="变量与类型"></a>变量与类型</h2><p>现在正式开始对 python 脚本进行了解</p><p>介绍几个基础数据类型：</p><ol><li>int </li><li>float</li><li>string</li><li>bool</li><li>complex，很少用</li></ol><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>规则：以字母，下划线，数字构成，数字不能开头，字母大小写敏感</p><p>PEP 8要求：</p><ul><li>一般用小写字母拼写，多个单词用下划线连接</li><li>受保护的实例属性用单个下划线开头（后面会讲到）</li><li>私有的实例属性用两个下划线开头（后面会讲到）</li></ul><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>python 中变量的创建不需要声明，直接赋值即创建。<strong>还可以使用内置函数，对变量类型进行转换：int(), float(), str()…使用 type() 查看变量类型</strong></p><p><strong>再介绍两个基础函数，print() &amp; input()，前者用于打印，后者用于接收键盘输入字符串</strong></p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>下表大致按照优先级从高到低的顺序列出了所有的运算符</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> `</td><td>`</td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td><td>=<code>`^=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></td><td>（复合）赋值运算符</td></tr></tbody></table></div><p>比较陌生的是位运算符，身份运算符，成员运算符，需要重点理解一下，参考 <a href="https://www.runoob.com/python/python-operators.html">菜鸟教程</a></p><h2 id="分支与循环"><a href="#分支与循环" class="headerlink" title="分支与循环"></a>分支与循环</h2><p>分支使用 if…elif…else 形式实现分支</p><p>循环有两种形式：for-in 和 while，重点提一下 for-in，用来对一个容器进行迭代非常方便，这个容器可以是列表，字典，元组等具有迭代功能的容器。使用 <code>break &amp; continue</code> 来跳出循环</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>python 使用 def 关键字声明函数，以 return 结束，如果没有 return 默认返回 None。在 python 中，函数的参数可以有默认值，也支持使用可变参数 *args, **kwargs</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="可更改对象与不可更改对象"><a href="#可更改对象与不可更改对象" class="headerlink" title="可更改对象与不可更改对象"></a>可更改对象与不可更改对象</h4><p>由于 python 中的变量不像 C 语言一样需要声明，所以 python 函数参数是传值还是引用，也和 C 语言不一样。由于 python 的变量不需要声明，那么 python 的变量与 C 语言变量有着本质的区别，举个例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token keyword">is</span> b<span class="token punctuation">)</span><span class="token comment"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到 a 和 b 其实是来自同一个对象，更改了 a 的值，b 也一起被更改了，就好像 a 和 b 的“指针”都指向了1</p><p>参考这个 <a href="http://winterttr.me/2015/10/24/python-passing-arguments-as-value-or-reference/">博客</a>， “类型是属于对象的，而不是变量的”，python 中的变量更像是一个“指针”，是对对象的引用，一个变量可以指向任意的对象。1是属于 int 对象的，而不是属于 a, b 变量的</p><p>现在回到参数传递这个话题，我认为可以认为是“引用”传递，但情况分为两种：</p><ol><li>传递参数为可更改对象 (mutable)，例如 list, dict, np.array，在函数中<strong>修改</strong>参数值时，会改变原变量；<strong>赋值</strong>新值时，不会改变原变量</li><li>传递参数为不可更改对象 (immutable)，例如 strings, numbers, tuples，在函数中<strong>赋值</strong>新值时，不会改变原变量，即原变量所指对象不变</li></ol><p>举个例子来理解一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'this is c'</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    c <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token comment"># -1 [-1, 2, 3] 0</span>    test<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token comment"># 1 [-1, 2, 3] ['this is c']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h4><p>这里参考 <a href="https://cloud.tencent.com/developer/article/1640717">python 参数，腾讯云</a> 进行整理。python 函数的形参分为四种：</p><ul><li>必需参数：平时最常用的，必传确定数量的参数</li><li>缺省参数：在调用函数时可以传也可以不传，如果不传将使用默认值</li><li>可变参数：可变长度参数，通常用 <code>*args</code> 表示</li><li>关键字参数：长度可变，但需要以 key=value 对形式传递，通常用 <code>**kwargs</code> 表示</li></ul><p>对于定义函数时，参数位置的强制要求有以下两点：</p><ol><li>缺省参数必须在必须参数之后</li><li>关键字参数必须在最后</li></ol><p>在给函数传入参数时，可以传入两种类型：</p><ul><li>位置参数：直接传入实参，传入位置与函数定义时的参数位置相同</li><li>关键字参数：以 <code>param=value</code> 形式出现，可以忽略函数定义时参数的位置</li></ul><p>python 强制要求位置参数必须在关键字参数之前</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'c'</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'必须参数: %s, %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'缺省参数: %s, %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'可变参数:'</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'关键字参数:'</span><span class="token punctuation">,</span> kwargs<span class="token punctuation">)</span>    test<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'--------------------------'</span><span class="token punctuation">)</span>test<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'C'</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token string">'e'</span><span class="token punctuation">)</span><span class="token comment"># 上面过早传入了关键字参数，导致无法传入可变参数 *args</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面冒号 <code>:</code> 之后表示的是作者建议的传入参数类型，箭头 <code>-&gt;</code> 之后为建议的函数返回类型</p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>当需要传入的多个参数被打包在了一个元组/字典中，可以通过解包的方式，直接把元组/字典作为可变参数/关键字参数，传入到函数当中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>kwargs <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>test<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token comment"># 1 2 3</span>test<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token comment"># a b c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码中可以看到，解包元组用  <code>*</code>，解包字典用 <code>**</code></p><h3 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h3><p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。lambda 只是一个表达式，函数体比 def 简单很多，所以只能封装有限的逻辑。lambda 函数的语法只有一句</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">lambda</span> <span class="token punctuation">[</span>args_list<span class="token punctuation">]</span><span class="token punctuation">:</span> expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>expression</code> 可以是表达式，也可以是一个函数。下面举一个例子来使用 lambda 函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">add <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">,</span> b<span class="token punctuation">:</span> a <span class="token operator">+</span> b<span class="token keyword">print</span><span class="token punctuation">(</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">exp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> a<span class="token operator">**</span>b<span class="token comment"># expression can be a function</span>exp_of_2 <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> exp<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>exp_of_2<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模块化管理"><a href="#模块化管理" class="headerlink" title="模块化管理"></a>模块化管理</h3><p>通过模块管理 python 文件/函数将会变得非常方便，需要使用的函数，使用关键字 <code>import</code> 导入即可，导入方法有如下：</p><ol><li><code>import module</code>：导入模块，以 <code>module.func</code> 使用模块中的函数等内容</li><li><code>import module ad md</code>：导入模块，命名为 md，使用方法类似1</li><li><code>from module import func</code>：直接从模块中导入函数，可直接使用 func()</li></ol><p>当我们使用 import 语句的时候，Python解释器是怎样找到对应的文件的呢？这就涉及到 Python 的搜索路径，搜索路径是由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块。搜索路径被存储在 sys 模块中的 path 变量，此变量为一个列表</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">for</span> path <span class="token keyword">in</span> sys<span class="token punctuation">.</span>path<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># d:\VScodeProjects\TestProj</span><span class="token comment"># D:\LenovoSoftstore\Anaconda\python38.zip</span><span class="token comment"># D:\LenovoSoftstore\Anaconda\lib\site-packages</span><span class="token comment"># ...MORE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般 <code>sys.path</code> 列表的第一个即为当前文件所在文件夹</p><h4 id="if-name-‘-main-‘"><a href="#if-name-‘-main-‘" class="headerlink" title="if __name__ = ‘__main__‘"></a>if __name__ = ‘__main__‘</h4><p>需要说明的是，如果导入的模块中有可执行的代码，那么在导入模块时就会执行。但事实上，我们可能不希望执行这些代码，只想要导入这个函数，例如下面的模块</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># module.py</span><span class="token keyword">def</span> <span class="token function">module_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is a module'</span><span class="token punctuation">)</span>module_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时如果在另一个 python 文件中 <code>import module</code> 将会看到输出 <code>this is a module</code>。为了避免这种情况，需要在模块中限定这些可执行代码，仅在该模块直接运行的时候运行，而不在导入的时候运行。可采取如下形式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># module.py</span><span class="token keyword">def</span> <span class="token function">module_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is a module'</span><span class="token punctuation">)</span><span class="token comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span><span class="token comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span><span class="token keyword">if</span> __name__ <span class="token operator">=</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>module_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里提到了一个隐含变量 <code>__name__</code>，是由 python 自动生成的变量，不需要人为定义。在 python 中有其他的隐含变量，例如 <code>__doc__</code> 用于保存对象的说明性文档，通过关键字 <code>?</code> 就能调出文档，<a href="https://blog.csdn.net/u011699626/article/details/107981264">CSDN doc参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件推荐</title>
      <link href="/archives/c92482f1.html"/>
      <url>/archives/c92482f1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-的软件"><a href="#Windows-的软件" class="headerlink" title="Windows 的软件"></a>Windows 的软件</h1><ol><li>Listary</li><li>potplayer + 简洁皮肤定制</li><li>bandzip</li><li>bilibili 直播姬</li><li>clash</li><li>滴答清单</li><li>chrome</li><li>印象笔记</li><li>typora</li><li>latex</li><li>vs code</li><li>zotero</li><li>git</li><li>QQ 微信 百度网盘 阿里云盘（目前不限速！）</li><li>ps pr</li><li>jiji download</li><li>youtube dl</li><li>arctime</li><li>WinSCP，Xshell</li><li>SpaceSniffer</li><li>utorrent</li></ol><h1 id="Ubuntu-的软件"><a href="#Ubuntu-的软件" class="headerlink" title="Ubuntu 的软件"></a>Ubuntu 的软件</h1><ol><li>vlc 视频播放器</li><li>filezilla (类似 WinSCP, 还没有尝试过)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MMDetection 笔记</title>
      <link href="/archives/6f4f5bd8.html"/>
      <url>/archives/6f4f5bd8.html</url>
      
        <content type="html"><![CDATA[<h1 id="MMDetection-note"><a href="#MMDetection-note" class="headerlink" title="MMDetection note"></a>MMDetection note</h1><p>整理自 <a href="https://mmdetection.readthedocs.io/en/latest/index.html">MMDetection 官方文档</a></p><h1 id="Quick-Run"><a href="#Quick-Run" class="headerlink" title="Quick Run"></a>Quick Run</h1><h2 id="Part-1-Inference-and-train-with-existing-models-and-standard-datasets"><a href="#Part-1-Inference-and-train-with-existing-models-and-standard-datasets" class="headerlink" title="Part 1, Inference and train with existing models and standard datasets"></a>Part 1, Inference and train with existing models and standard datasets</h2><blockquote><p>MMDetection provides hundreds of existing and existing detection models in <a href="https://mmdetection.readthedocs.io/en/latest/model_zoo.html">Model Zoo</a>, and supports multiple standard datasets, including Pascal VOC, COCO, CityScapes, LVIS, etc.</p></blockquote><p>这一部分将简要介绍，如何使用 MMDetection 对 Model zoo 中的模型进行测试和训练</p><h3 id="Inference-with-existing-models"><a href="#Inference-with-existing-models" class="headerlink" title="Inference with existing models"></a>Inference with existing models</h3><blockquote><p>By inference, we mean using trained models to detect objects on images. In MMDetection, a model is defined by a configuration file and existing model parameters are save in a checkpoint file.</p></blockquote><p>这里介绍了 MMDetection 模型表示的基本逻辑：<code>configuration file</code>+ <code>checkpoint file</code> </p><p>文档以 Faster R-CNN 为例子，如何进行目标检测推理</p><blockquote><p>To start with, we recommend <a href="https://github.com/open-mmlab/mmdetection/tree/master/configs/faster_rcnn">Faster RCNN</a> with this <a href="https://github.com/open-mmlab/mmdetection/blob/master/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py">configuration file</a> and this <a href="https://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth">checkpoint file</a>. It is recommended to download the checkpoint file to <code>checkpoints</code> directory.</p></blockquote><p>Q: config files 名字的意义是什么？在 config 对应的文件夹中有 markdown 文档进行说明，例如 <a href="https://github.com/open-mmlab/mmdetection/tree/master/configs/faster_rcnn">faster rcnn</a> </p><h4 id="High-level-APIs-for-inference"><a href="#High-level-APIs-for-inference" class="headerlink" title="High-level APIs for inference"></a>High-level APIs for inference</h4><p>在之前也见到过这个代码，现在再来看一看</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> mmdet<span class="token punctuation">.</span>apis <span class="token keyword">import</span> init_detector<span class="token punctuation">,</span> inference_detector<span class="token keyword">import</span> mmcv<span class="token comment"># Specify the path to model config and checkpoint file</span>config_file <span class="token operator">=</span> <span class="token string">'configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py'</span>checkpoint_file <span class="token operator">=</span> <span class="token string">'checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'</span><span class="token comment"># build the model from a config file and a checkpoint file</span>model <span class="token operator">=</span> init_detector<span class="token punctuation">(</span>config_file<span class="token punctuation">,</span> checkpoint_file<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">'cuda:0'</span><span class="token punctuation">)</span><span class="token comment"># test a single image and show the results</span>img <span class="token operator">=</span> <span class="token string">'test.jpg'</span>  <span class="token comment"># or img = mmcv.imread(img), which will only load it once</span>result <span class="token operator">=</span> inference_detector<span class="token punctuation">(</span>model<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token comment"># visualize the results in a new window</span>model<span class="token punctuation">.</span>show_result<span class="token punctuation">(</span>img<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token comment"># or save the visualization results to image files</span>model<span class="token punctuation">.</span>show_result<span class="token punctuation">(</span>img<span class="token punctuation">,</span> result<span class="token punctuation">,</span> out_file<span class="token operator">=</span><span class="token string">'result.jpg'</span><span class="token punctuation">)</span><span class="token comment"># test a video and show the results</span>video <span class="token operator">=</span> mmcv<span class="token punctuation">.</span>VideoReader<span class="token punctuation">(</span><span class="token string">'video.mp4'</span><span class="token punctuation">)</span><span class="token keyword">for</span> frame <span class="token keyword">in</span> video<span class="token punctuation">:</span>    result <span class="token operator">=</span> inference_detector<span class="token punctuation">(</span>model<span class="token punctuation">,</span> frame<span class="token punctuation">)</span>    model<span class="token punctuation">.</span>show_result<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> result<span class="token punctuation">,</span> wait_time<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中用到了是这三个 API:</p><ol><li>异步推理 <code>async_inference_detector</code></li><li>绘制 <code>show_result</code></li><li>推理 <code>inference_detector</code></li></ol><p>这里 <code>show_result</code> 的参数请查看 <a href="https://github.com/open-mmlab/mmdetection/blob/a1cecf63c713c53941b8dcf8a9d762baf8511f2c/mmdet/models/detectors/base.py">原代码</a>，如果需要显示的话要添加参数 <code>show=True</code>。但在用 vscode 连接远程服务器的情况下，即使设置了 <code>show=True</code> 也不会展示结果，可能因为服务器不支持 GUI，替代的方法就是在 Jupyter notebook 或者 interactive window 中运行</p><h4 id="Asynchronous-interface-supported-for-Python-3-7"><a href="#Asynchronous-interface-supported-for-Python-3-7" class="headerlink" title="Asynchronous interface - supported for Python 3.7+"></a>Asynchronous interface - supported for Python 3.7+</h4><p>这一节没有理解清楚，只稍微留了点印象：使用异步接口理论上能够加速推理/训练过程</p><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>首先什么是 <a href="https://blog.csdn.net/lemon4869/article/details/107145903">异步思维</a>，在链接中的理解来说：异步就是不必等待推理结束才开始下一张图像的预处理。但看原代码说的异步到底是什么意思，我也不太理解，以后再回来整理 asyncio 相关知识吧</p><h5 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h5><p>什么是 Asynchronous interface <a href="https://zhuanlan.zhihu.com/p/353857526">知乎链接</a></p><p>什么是 asyncio <a href="https://blog.csdn.net/permike/article/details/110821246">知乎链接</a></p><p>Q: 这里需要更多的 python 知识，我得回去补充，比如 with 关键字什么意思？整个异步的过程是怎么样的，能否把整个时间与事件弄清楚？</p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>文档给了3个demo：</p><ol><li>Image Demo</li><li>Webcam Demo</li><li>Video Demo</li></ol><p>简单看了一下代码，看来还需要补充总结 OpenCV 的一些基础知识</p><h3 id="Test-existing-models-on-standard-datasets"><a href="#Test-existing-models-on-standard-datasets" class="headerlink" title="Test existing models on standard datasets"></a>Test existing models on standard datasets</h3><blockquote><p>MMDetection supports multiple public datasets including COCO, Pascal VOC, CityScapes, and <a href="https://github.com/open-mmlab/mmdetection/tree/master/configs/_base_/datasets">more</a>. This section will show how to test existing models on supported datasets.</p></blockquote><h4 id="Prepare-datasets"><a href="#Prepare-datasets" class="headerlink" title="Prepare datasets"></a>Prepare datasets</h4><p>推荐在项目之外建立数据集，然后以软链接的形式放到项目中，且目录结构要根据 config files 规放置（或者你自己修改 config files），举个几个例子</p><pre class="line-numbers language-none"><code class="language-none">mmdetection├── mmdet├── tools├── configs├── data│   ├── coco│   │   ├── annotations│   │   ├── train2017│   │   ├── val2017│   │   ├── test2017│   ├── cityscapes│   │   ├── annotations│   │   ├── leftImg8bit│   │   │   ├── train│   │   │   ├── val│   │   ├── gtFine│   │   │   ├── train│   │   │   ├── val│   ├── VOCdevkit│   │   ├── VOC2007│   │   ├── VOC2012<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Test-existing-models"><a href="#Test-existing-models" class="headerlink" title="Test existing models"></a>Test existing models</h4><blockquote><p>We provide testing scripts for evaluating an existing model on the whole dataset (COCO, PASCAL VOC, Cityscapes, etc.). </p></blockquote><p>可以在单个 GPU 上测试，也可以在多个 GPU 上进行分布测试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># single-gpu testing</span>python tools/test.py <span class="token punctuation">\</span>    <span class="token variable">${CONFIG_FILE}</span> <span class="token punctuation">\</span>    <span class="token variable">${CHECKPOINT_FILE}</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>--out <span class="token variable">${RESULT_FILE}</span><span class="token punctuation">]</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>--eval <span class="token variable">${EVAL_METRICS}</span><span class="token punctuation">]</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>--show<span class="token punctuation">]</span><span class="token comment"># multi-gpu testing</span><span class="token function">bash</span> tools/dist_test.sh <span class="token punctuation">\</span>    <span class="token variable">${CONFIG_FILE}</span> <span class="token punctuation">\</span>    <span class="token variable">${CHECKPOINT_FILE}</span> <span class="token punctuation">\</span>    <span class="token variable">${GPU_NUM}</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>--out <span class="token variable">${RESULT_FILE}</span><span class="token punctuation">]</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>--eval <span class="token variable">${EVAL_METRICS}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mmdetection 提供对无标记数据集进行测试，但数据集需要符合 COCO format，如果不是 COCO format 例如 VOC 数据集，需要使用 <a href="https://github.com/open-mmlab/mmdetection/tree/master/tools/dataset_converters/pascal_voc.py">script in tools</a> 转化</p><p>mmdetection 提供 batch inference，能够一次推理多个样本，在 config files 中修改 <code>sample_per_gpu</code> 即可，或者使用 <code>--cfg-options data.test.samples_per_gpu=2</code></p><p>还有很多参数可以调整，具体请看源代码，文档也给出了很多 <a href="https://mmdetection.readthedocs.io/en/latest/1_exist_data_model.html#examples">例子</a></p><h4 id="Train-predefined-models-on-standard-datasets"><a href="#Train-predefined-models-on-standard-datasets" class="headerlink" title="Train predefined models on standard datasets"></a>Train predefined models on standard datasets</h4><blockquote><p>This section will show how to train <em>predefined</em> models (under <a href="https://github.com/open-mmlab/mmdetection/tree/master/configs">configs</a>) on standard datasets i.e. COCO.</p><p><strong>Important</strong>: 训练的默认学习率的配置为 8个 GPU 和 2 img/gpu，也就是 batch size 为16，如果使用不同的 batch size 那么就要按照线性缩放原则更改学习率 e.g., <code>lr=0.01</code> for 4 GPUs <em> 2 imgs/gpu and <code>lr=0.08</code> for 16 GPUs </em> 4 imgs/gpu.</p></blockquote><h5 id="Prepare-datasets-1"><a href="#Prepare-datasets-1" class="headerlink" title="Prepare datasets"></a>Prepare datasets</h5><p>准备过程和上一节 Test 部分是一致的。建议先将模型下载好，以防网不好导致报错</p><h5 id="Training-on-a-single-GPU"><a href="#Training-on-a-single-GPU" class="headerlink" title="Training on a single GPU"></a>Training on a single GPU</h5><p>在单个 GPU 上训练，基本使用方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python tools/train.py <span class="token punctuation">\</span>    <span class="token variable">${CONFIG_FILE}</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>optional arguments<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>训练过程中的 log 和 checkpoints 都会被存放到 <code>work_dir</code> 当中，也可以用 <code>--work-dir</code> 重新指定</p><p>默认每12个 epoch 使用验证集对模型进行一次评估 evaluation，train.py 还接受一些常用参数：</p><ul><li><code>--no-validate</code> (<strong>not suggested</strong>): Disable evaluation during training.</li><li><code>--work-dir ${WORK_DIR}</code>: Override the working directory.</li><li><code>--resume-from ${CHECKPOINT_FILE}</code>: Resume from a previous checkpoint file.</li><li><code>--options 'Key=value'</code>: Overrides other settings in the used config.</li></ul><p>文档提到两个参数的区别：<code>--resume-from &amp; --load-from</code> 前者不仅加载参数权重，也加载 optimizer 的状态，主要用于训练被突然打断后接着训练。后者只加载参数权重，主要用于 finetuning</p><h4 id="Training-on-multiple-GPUs"><a href="#Training-on-multiple-GPUs" class="headerlink" title="Training on multiple GPUs"></a>Training on multiple GPUs</h4><p>同样，基本用法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">bash</span> ./tools/dist_train.sh <span class="token punctuation">\</span>    <span class="token variable">${CONFIG_FILE}</span> <span class="token punctuation">\</span>    <span class="token variable">${GPU_NUM}</span> <span class="token punctuation">\</span>    <span class="token punctuation">[</span>optional arguments<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可选参数和上面训练单个 GPU 是一样的</p><h5 id="Launch-multiple-jobs-simultaneously"><a href="#Launch-multiple-jobs-simultaneously" class="headerlink" title="Launch multiple jobs simultaneously"></a>Launch multiple jobs simultaneously</h5><p>在训练当中，通常会有多任务的存在，mmdetection 也可以实现，但现在能力有限，实在不能理解具体的实现逻辑，留个 <a href="https://mmdetection.readthedocs.io/en/latest/1_exist_data_model.html#training-on-multiple-gpus">原文档链接</a></p><p>提到了很多新东西，nodes, port, slurm, pytorch launch utility…如果能够在实践中理解这些概念更好了</p><h2 id="Part-2-Train-with-customized-datasets"><a href="#Part-2-Train-with-customized-datasets" class="headerlink" title="Part 2, Train with customized datasets"></a>Part 2, Train with customized datasets</h2><blockquote><p> We use the <a href="https://github.com/matterport/Mask_RCNN/tree/master/samples/balloon">balloon dataset</a> as an example to describe the whole process.</p></blockquote><p>基本步骤为：</p><ol><li>Prepare the customized dataset</li><li>Prepare a config</li><li>Train, test, inference models on the customized dataset.</li></ol><h3 id="Prepare-the-customized-dataset"><a href="#Prepare-the-customized-dataset" class="headerlink" title="Prepare the customized dataset"></a>Prepare the customized dataset</h3><p>mmdetection 支持对 COCO format 数据集进行训练，将不同格式的数据集转化为 COCO format 即可。可能也可以对 config file 进行配置，来适配不同格式的数据集，但这一部分文档没有提及</p><h4 id="COCO-annotation-format"><a href="#COCO-annotation-format" class="headerlink" title="COCO annotation format"></a>COCO annotation format</h4><blockquote><p>The necessary keys of COCO format for instance segmentation is as below, for the complete details, please refer <a href="https://cocodataset.org/#format-data">here</a>.</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"images"</span><span class="token operator">:</span> <span class="token punctuation">[</span>image<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"annotations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>annotation<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"categories"</span><span class="token operator">:</span> <span class="token punctuation">[</span>category<span class="token punctuation">]</span><span class="token punctuation">}</span>image = <span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"width"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"height"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"file_name"</span><span class="token operator">:</span> str<span class="token punctuation">,</span><span class="token punctuation">}</span>annotation = <span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"image_id"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"category_id"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"segmentation"</span><span class="token operator">:</span> RLE or <span class="token punctuation">[</span>polygon<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"area"</span><span class="token operator">:</span> float<span class="token punctuation">,</span>    <span class="token property">"bbox"</span><span class="token operator">:</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>width<span class="token punctuation">,</span>height<span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"iscrowd"</span><span class="token operator">:</span> <span class="token number">0</span> or <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span>categories = <span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"id"</span><span class="token operator">:</span> int<span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> str<span class="token punctuation">,</span>    <span class="token property">"supercategory"</span><span class="token operator">:</span> str<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>balloon dataset format 形如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>'base64_img_data'<span class="token operator">:</span> ''<span class="token punctuation">,</span> 'file_attributes'<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 'filename'<span class="token operator">:</span> '34020010494_e5cb88e1c4_k.jpg'<span class="token punctuation">,</span> 'fileref'<span class="token operator">:</span> ''<span class="token punctuation">,</span> 'regions'<span class="token operator">:</span> <span class="token punctuation">{</span>'<span class="token number">0</span>'<span class="token operator">:</span> <span class="token punctuation">{</span>'region_attributes'<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>   'shape_attributes'<span class="token operator">:</span> <span class="token punctuation">{</span>'all_points_x'<span class="token operator">:</span> <span class="token punctuation">[</span>...<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    'all_points_y'<span class="token operator">:</span> <span class="token punctuation">[</span>...<span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    'name'<span class="token operator">:</span> 'polygon'<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 'size'<span class="token operator">:</span> <span class="token number">1115004</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文档提供了函数将 balloon dataset JSON 格式转化为 COCO format，<a href="https://mmdetection.readthedocs.io/en/latest/2_new_data_model.html#coco-annotation-format">原文档</a></p><h3 id="Prepare-a-config"><a href="#Prepare-a-config" class="headerlink" title="Prepare a config"></a>Prepare a config</h3><blockquote><p>The second step is to prepare a config thus the dataset could be successfully loaded. </p></blockquote><p>假设以 balloon dataset 训练 Mask R-CNN with FPN，config 在 <code>configs/balloon</code> 命名为  <code>mask_rcnn_r50_caffe_fpn_mstrain-poly_1x_balloon.py</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># The new config inherits a base config to highlight the necessary modification</span>_base_ <span class="token operator">=</span> <span class="token string">'mask_rcnn/mask_rcnn_r50_caffe_fpn_mstrain-poly_1x_coco.py'</span><span class="token comment"># We also need to change the num_classes in head to match the dataset's annotation</span>model <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>    roi_head<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>        bbox_head<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>num_classes<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        mask_head<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>num_classes<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Modify dataset related settings</span>dataset_type <span class="token operator">=</span> <span class="token string">'COCODataset'</span>classes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'balloon'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>data <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>    train<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>        img_prefix<span class="token operator">=</span><span class="token string">'balloon/train/'</span><span class="token punctuation">,</span>        classes<span class="token operator">=</span>classes<span class="token punctuation">,</span>        ann_file<span class="token operator">=</span><span class="token string">'balloon/train/annotation_coco.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    val<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>        img_prefix<span class="token operator">=</span><span class="token string">'balloon/val/'</span><span class="token punctuation">,</span>        classes<span class="token operator">=</span>classes<span class="token punctuation">,</span>        ann_file<span class="token operator">=</span><span class="token string">'balloon/val/annotation_coco.json'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    test<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>        img_prefix<span class="token operator">=</span><span class="token string">'balloon/val/'</span><span class="token punctuation">,</span>        classes<span class="token operator">=</span>classes<span class="token punctuation">,</span>        ann_file<span class="token operator">=</span><span class="token string">'balloon/val/annotation_coco.json'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># We can use the pre-trained Mask RCNN model to obtain higher performance</span>load_from <span class="token operator">=</span> <span class="token string">'checkpoints/mask_rcnn_r50_caffe_fpn_mstrain-poly_3x_coco_bbox_mAP-0.408__segm_mAP-0.37_20200504_163245-42aa3d00.pth'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Train-amp-Test-Model"><a href="#Train-amp-Test-Model" class="headerlink" title="Train &amp; Test Model"></a>Train &amp; Test Model</h3><p>配置好了数据集过后，基本上就和 Part 1 中的训练和测试方法一样</p><p>To train a model with the new config, you can simply run</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python tools/train.py configs/balloon/mask_rcnn_r50_caffe_fpn_mstrain-poly_1x_balloon.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To test the trained model, you can simply run</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python tools/test.py configs/balloon/mask_rcnn_r50_caffe_fpn_mstrain-poly_1x_balloon.py <span class="token punctuation">\</span>work_dirs/mask_rcnn_r50_caffe_fpn_mstrain-poly_1x_balloon.py/latest.pth <span class="token punctuation">\</span>--eval bbox segm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Part-3-Train-with-customized-models-and-standard-datasets"><a href="#Part-3-Train-with-customized-models-and-standard-datasets" class="headerlink" title="Part 3, Train with customized models and standard datasets"></a>Part 3, Train with customized models and standard datasets</h2><blockquote><p>In this note, you will know how to train, test and inference your own customized models under standard datasets.</p></blockquote><p>使用 cityscapes dataset 训练个性化 Cascade Mask R-CNN R50 model，使用 <a href="https://github.com/Gus-Guo/AugFPN"><code>AugFPN</code></a> 替代 <code>FPN</code> 作为 neck，并且加上 <code>Rotate</code> or <code>Translate</code> 作为数据增强</p><p>基本步骤比 Part 2 多一个准备 customized model:</p><ol><li>Prepare the standard dataset</li><li>Prepare your own customized model</li><li>Prepare a config</li><li>Train, test, and inference models on the standard dataset</li></ol><h3 id="Prepare-the-standard-dataset"><a href="#Prepare-the-standard-dataset" class="headerlink" title="Prepare the standard dataset"></a>Prepare the standard dataset</h3><p>基本流程，也是需要将 cityscapes dataset 转为 COCO format，mmdetection 也提供转化脚本 <code>tools/dataset_converters/cityscapes.py</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip <span class="token function">install</span> cityscapesscriptspython tools/dataset_converters/cityscapes.py ./data/cityscapes --nproc <span class="token number">8</span> --out-dir ./data/cityscapes/annotations<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Prepare-your-own-customized-model"><a href="#Prepare-your-own-customized-model" class="headerlink" title="Prepare your own customized model"></a>Prepare your own customized model</h3><h4 id="1-Define-a-new-neck-e-g-AugFPN"><a href="#1-Define-a-new-neck-e-g-AugFPN" class="headerlink" title="1. Define a new neck (e.g. AugFPN)"></a>1. Define a new neck (e.g. AugFPN)</h4><p>首先新建一个文件 <code>mmdet/models/necks/augfpn.py</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>builder <span class="token keyword">import</span> NECKS@NECKS<span class="token punctuation">.</span>register_module<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">AugFPN</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>                in_channels<span class="token punctuation">,</span>                out_channels<span class="token punctuation">,</span>                num_outs<span class="token punctuation">,</span>                start_level<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>                end_level<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                add_extra_convs<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># implementation is ignored        pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意这里用了一个装饰器，复习 python 的时候可以联系起来</p><h4 id="2-Import-the-module"><a href="#2-Import-the-module" class="headerlink" title="2. Import the module"></a>2. Import the module</h4><p>导入模块有两种方法：</p><ol><li><p>在  <code>mmdet/models/necks/__init__.py</code> 导入</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span>augfpn <span class="token keyword">import</span> AugFPN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在 config 文件中更改</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">custom_imports <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>    imports<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'mmdet.models.necks.augfpn.py'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    allow_failed_imports<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样就避免去更改原文件</p></li></ol><h4 id="3-Modify-the-config-file"><a href="#3-Modify-the-config-file" class="headerlink" title="3. Modify the config file"></a>3. Modify the config file</h4><p>将 neck 加入到 config file 中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">neck<span class="token operator">=</span><span class="token builtin">dict</span><span class="token punctuation">(</span>    <span class="token builtin">type</span><span class="token operator">=</span><span class="token string">'AugFPN'</span><span class="token punctuation">,</span>    in_channels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    out_channels<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>    num_outs<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，如果想要更改别人的模型，mmdetection 都是以 config file 为核心，而不去更改原文件</p><p>如果要完成 AugFPN, Rotate, Translate 三个修改的话，在文档中给出了参考的 <a href="https://mmdetection.readthedocs.io/en/latest/3_exist_data_new_model.html#prepare-a-config">config file</a></p><h3 id="Train-amp-Test-Model-1"><a href="#Train-amp-Test-Model-1" class="headerlink" title="Train &amp; Test Model"></a>Train &amp; Test Model</h3><p>训练和测试基本使用方法在之前已经介绍过，这部分也一样</p><p>To train a model with the new config, you can simply run</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python tools/train.py configs/cityscapes/cascade_mask_rcnn_r50_augfpn_autoaug_10e_cityscapes.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To test the trained model, you can simply run</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python tools/test.py configs/cityscapes/cascade_mask_rcnn_r50_augfpn_autoaug_10e_cityscapes.py <span class="token punctuation">\</span>work_dirs/cascade_mask_rcnn_r50_augfpn_autoaug_10e_cityscapes.py/latest.pth --eval bbox segm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="pth文件里有什么"><a href="#pth文件里有什么" class="headerlink" title=".pth文件里有什么"></a>.pth文件里有什么</h3><p>要回答一个问题，什么是 <a href="https://zhuanlan.zhihu.com/p/84797438">.pth 文件 知乎</a>，在 mmdetection 框架中可以看到 pth 文件包含了两个部分 <code>meta &amp; state_dict</code></p><p>其中 <code>meta</code> 保存了模型的配置信息，列出其 key：</p><ol><li>mmdet_version</li><li><strong>config</strong></li><li>CLASSES</li><li>epoch</li><li>iter</li><li>mmcv_version</li><li>time</li></ol><p>而 <code>state_dict</code> 保存了模型参数值，列出部分 key：</p><p>backbone.conv1.weight<br>backbone.bn1.weight<br>backbone.bn1.bias<br>backbone.bn1.running_mean<br>backbone.bn1.running_var<br>backbone.bn1.num_batches_tracked<br>backbone.layer1.0.conv1.weight<br>backbone.layer1.0.bn1.weight<br>backbone.layer1.0.bn1.bias<br>backbone.layer1.0.bn1.running_mean<br>backbone.layer1.0.bn1.running_var<br>backbone.layer1.0.bn1.num_batches_tracked</p><p>…….</p><h3 id="如何理解-Registry"><a href="#如何理解-Registry" class="headerlink" title="如何理解 Registry"></a>如何理解 Registry</h3><p>在学习 mmdetection 过程中一直又一个问题：如何使用 config + registry 返回一个 nn.Module 类的模型，这些模型是如何被注册到 Registry 类当中的？</p><p>阅读资源：</p><ol><li><p><a href="https://blog.csdn.net/sinat_29963957">mmdetection 源码阅读笔记</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/337375549">mmdetection 整体构建流程</a></p></li><li><p><a href="https://blog.csdn.net/wulele2/article/details/114139512">mmdetection之model构建</a></p></li><li><p><a href="https://mmtracking.readthedocs.io/en/latest/">MMCV 官方文档</a>，这个文档相当有用，是 mmlab 的通用基础库，要好好学习一下</p></li><li><p><a href="https://www.cnblogs.com/hester/p/10546235.html#:~:text=Python%E4%B8%AD%E4%B8%80%E4%B8%AApy%E6%96%87%E4%BB%B6%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%8C%E2%80%9C__all__%E2%80%9D%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8py%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%8C%85%E7%9A%84__init__.py%E4%B8%AD%E5%87%BA%E7%8E%B0%E3%80%82%20%E5%A6%82%EF%BC%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E7%B1%BB%E3%80%82%20%E5%A6%82%E4%B8%8B%EF%BC%8Ctest1.py%E5%92%8Cmain.py,%3F%20%3F%20%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82%20%E9%82%A3%E4%B9%88%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84__all__%E5%8F%98%E9%87%8F%E5%B0%B1%E6%98%AF%E4%B8%BA%E4%BA%86%E9%99%90%E5%88%B6%E6%88%96%E8%80%85%E6%8C%87%E5%AE%9A%E8%83%BD%E8%A2%AB%E5%AF%BC%E5%85%A5%E5%88%B0%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E7%B1%BB%EF%BC%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%AD%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E5%AE%9A%E4%BA%86%E9%82%A3%E4%B9%88%E5%8F%AA%E8%83%BD%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84%E9%82%A3%E4%BA%9B%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AF%BC%E5%85%A5%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%B0%B1%E6%98%AF%E5%85%A8%E9%83%A8%E5%8F%AF%E4%BB%A5%E5%AF%BC%E5%85%A5%EF%BC%8C%E5%BD%93%E7%84%B6%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%BA%94%E8%AF%A5%E9%99%A4%E5%A4%96%E3%80%82">python _<em>all_</em>变量</a></p></li><li>在 B 站上找到了一个官方 <a href="https://space.bilibili.com/630319191/channel/detail?cid=179690&amp;ctype=0">学习讲座系列</a>，这个讲座不太和我胃口，又在 B 站上找了一个西交的 <a href="https://www.bilibili.com/video/BV1Jb4y1r7ir?p=1">教学视频</a>，这个视频就比较友好，对我帮助更大</li></ol><p>我一直都很不理解这些类是怎么注册的，为什么有的代码似乎没有“明显”地运行，但是这些模块就已经被注册到 Registry 当中了？看完 MMCV 文档之后才大概明白了，重点就在于 <code>__init__.py</code> 文件以及 <code>__all__</code> 变量。可以看到在许多文件夹下都有 <code>__init__.py</code> 文件，例如 <code>mmdet/models/__init__.py</code>, <code>mmdet/models/backbones/__init__.py</code></p><p>如果 import 文件夹/模块下又 init.py 文件，那么就会在 import 该模块之前先运行 init.py 文件，就是在这个文件之中完成了各个模块的注册，其中 <code>__all__</code> 变量包含了需要导入的模块列表</p><p>具体看一下其中的内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span>backbones <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span><span class="token keyword">from</span> <span class="token punctuation">.</span>builder <span class="token keyword">import</span> <span class="token punctuation">(</span>BACKBONES<span class="token punctuation">,</span> DETECTORS<span class="token punctuation">,</span> HEADS<span class="token punctuation">,</span> LOSSES<span class="token punctuation">,</span> NECKS<span class="token punctuation">,</span>                      ROI_EXTRACTORS<span class="token punctuation">,</span> SHARED_HEADS<span class="token punctuation">,</span> build_backbone<span class="token punctuation">,</span>                      build_detector<span class="token punctuation">,</span> build_head<span class="token punctuation">,</span> build_loss<span class="token punctuation">,</span> build_neck<span class="token punctuation">,</span>                      build_roi_extractor<span class="token punctuation">,</span> build_shared_head<span class="token punctuation">)</span><span class="token keyword">from</span> <span class="token punctuation">.</span>dense_heads <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span><span class="token keyword">from</span> <span class="token punctuation">.</span>detectors <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span><span class="token keyword">from</span> <span class="token punctuation">.</span>losses <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span><span class="token keyword">from</span> <span class="token punctuation">.</span>necks <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span><span class="token keyword">from</span> <span class="token punctuation">.</span>plugins <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span><span class="token keyword">from</span> <span class="token punctuation">.</span>roi_heads <span class="token keyword">import</span> <span class="token operator">*</span>  <span class="token comment"># noqa: F401,F403</span>__all__ <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'BACKBONES'</span><span class="token punctuation">,</span> <span class="token string">'NECKS'</span><span class="token punctuation">,</span> <span class="token string">'ROI_EXTRACTORS'</span><span class="token punctuation">,</span> <span class="token string">'SHARED_HEADS'</span><span class="token punctuation">,</span> <span class="token string">'HEADS'</span><span class="token punctuation">,</span> <span class="token string">'LOSSES'</span><span class="token punctuation">,</span>    <span class="token string">'DETECTORS'</span><span class="token punctuation">,</span> <span class="token string">'build_backbone'</span><span class="token punctuation">,</span> <span class="token string">'build_neck'</span><span class="token punctuation">,</span> <span class="token string">'build_roi_extractor'</span><span class="token punctuation">,</span>    <span class="token string">'build_shared_head'</span><span class="token punctuation">,</span> <span class="token string">'build_head'</span><span class="token punctuation">,</span> <span class="token string">'build_loss'</span><span class="token punctuation">,</span> <span class="token string">'build_detector'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Bug-amp-vscode-debugger"><a href="#Bug-amp-vscode-debugger" class="headerlink" title="Bug  &amp; vscode debugger"></a>Bug  &amp; vscode debugger</h3><p>捣鼓了一天了在服务器，怎么都不能够搞好 xrdp，还差点把电脑弄出点毛病…最后用 <code>sudo dpkg --purge xrdp</code> 删除了没有下载完全的包才弄好了。我认为实验室的服务器需要一个大更新，一个是系统升级，另一个是清理内存，现在大概还有350G的空间剩余，最重要的是服务器的网络是个大问题！很多资源都无法直接下载，有些资源下载起来非常吃力</p><p>放一个 <a href="https://www.jianshu.com/p/ceb3c020e06b">nvidia-smi讲解链接</a>，理解一下各个指标是在说什么</p><h4 id="vscode-debugger"><a href="#vscode-debugger" class="headerlink" title="vscode debugger"></a>vscode debugger</h4><p>在使用 vscode debug 的时候发现有的代码并不会 step in，后来发现这些代码都是通过 pip/conda install 下载的库中的代码。而 vscode 的 debugger 会默认设定只在 ‘MyCode’ 中进行 debug，简单的说，如果不是“自己”写的代码，vscode debugger 是不会 step in 的</p><p>解决办法：在 debugger 的 json 文件中设置 <code>"justMyCode: false"</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token comment">// Use IntelliSense to learn about possible attributes.</span>    <span class="token comment">// Hover to view descriptions of existing attributes.</span>    <span class="token comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Python: Current File"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"python"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"${file}"</span><span class="token punctuation">,</span>            <span class="token property">"console"</span><span class="token operator">:</span> <span class="token string">"integratedTerminal"</span><span class="token punctuation">,</span>            <span class="token comment">// add the next line into your .json file</span>            <span class="token property">"justMyCode"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li><p>还需要整理 MMCV 以了解整个 OpenMMLab 的运行逻辑 </p></li><li><p>对于如何训练自己的网络还要继续看文档中的 Tutorial 部分</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> OpenMMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MMDetection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装 MMDetection 笔记</title>
      <link href="/archives/54605061.html"/>
      <url>/archives/54605061.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-MMDetection-笔记"><a href="#安装-MMDetection-笔记" class="headerlink" title="安装 MMDetection 笔记"></a>安装 MMDetection 笔记</h1><p>想法：通过这种标准化的算法框架，来进行组合实验</p><p>但是目前 SE-SSD 没有支持，可以尝试组合一下</p><h2 id="OpenMMLab"><a href="#OpenMMLab" class="headerlink" title="OpenMMLab"></a>OpenMMLab</h2><p>官网：<a href="https://openmmlab.com/">https://openmmlab.com/</a></p><p>github: <a href="https://github.com/open-mmlab">https://github.com/open-mmlab</a></p><p>子项目官方文档：<a href="https://mmdetection.readthedocs.io/zh_CN/latest/">MMDetection</a> <a href="https://mmdetection3d.readthedocs.io/zh_CN/latest/index.html">MMDetection3D</a></p><p>什么是 OpenMMLab？什么是 MMDdetction？</p><blockquote><p>OpenMMLab 是一个计算机视觉开源算法体系和框架，涉及超过10种研究方向，开放超过100种算法、800种预训练模型</p><p>MMDetection is an open source object detection toolbox based on PyTorch. It is a part of the OpenMMLab project.</p></blockquote><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>我打算先熟悉 MMDetection，因为这个项目在 github 上 star 是相对较多的，然后再进一步学习 mmdetection 3D，下面来安装 MMDetection 环境</p><p>首先看看依赖的要求</p><ul><li>Linux 和 macOS （Windows 理论上支持）</li><li>Python 3.6+</li><li>PyTorch 1.3+</li><li>CUDA 9.2+ （如果基于 PyTorch 源码安装，也能够支持 CUDA 9.0）</li><li>GCC 5+</li><li><a href="https://mmcv.readthedocs.io/en/latest/#installation">MMCV</a></li></ul><p>之后下载的依赖版本参考要求来</p><ol><li><p>创建 conda 环境 <code>conda create -n mmlab python=3.7</code></p></li><li><p>安装 pytorch</p><p>在 <a href="https://pytorch.org/get-started/previous-versions/">pytorch previous versions</a> 中查找你想要的版本，我选择如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda <span class="token function">install</span> <span class="token assign-left variable">pytorch</span><span class="token operator">==</span><span class="token number">1.5</span>.1 <span class="token assign-left variable">torchvision</span><span class="token operator">==</span><span class="token number">0.6</span>.1 <span class="token assign-left variable">cudatoolkit</span><span class="token operator">=</span><span class="token number">10.1</span> -c pytorch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但我电脑上安装的 CUDA 版本为10.0，之后看看这样做有什么区别</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nvcc: NVIDIA <span class="token punctuation">(</span>R<span class="token punctuation">)</span> Cuda compiler driverCopyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token number">2005</span>-2018 NVIDIA CorporationBuilt on Sat_Aug_25_21:08:01_CDT_2018Cuda compilation tools, release <span class="token number">10.0</span>, V10.0.130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="安装-MMDetection"><a href="#安装-MMDetection" class="headerlink" title="安装 MMDetection"></a>安装 MMDetection</h2><p>官方推荐使用 <a href="https://github.com/open-mmlab/mim">MIM</a> 安装 MMDetection</p><blockquote><p>MIM provides a unified interface for launching and installing OpenMMLab projects and their extensions, and managing the OpenMMLab model zoo.</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip <span class="token function">install</span> openmimmim <span class="token function">install</span> mmdet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MIM 自动下载了 mmdet 及其对应依赖</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># mim list</span>Package    Version    Source---------  ---------  -----------------------------------------mmcv-full  <span class="token number">1.3</span>.10     https://github.com/open-mmlab/mmcvmmdet      <span class="token number">2.15</span>.0     https://github.com/open-mmlab/mmdetection<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>将 MMDetection 仓库克隆到本地，运行如下代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> mmdet<span class="token punctuation">.</span>apis <span class="token keyword">import</span> inference_detector<span class="token punctuation">,</span> init_detectorconfig_file <span class="token operator">=</span> <span class="token string">'configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py'</span><span class="token comment"># 从 model zoo 下载 checkpoint 并放在 `checkpoints/` 文件下</span><span class="token comment"># 网址为: http://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth</span>checkpoint_file <span class="token operator">=</span> <span class="token string">'checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'</span>device <span class="token operator">=</span> <span class="token string">'cuda:0'</span><span class="token comment"># 初始化检测器</span>model <span class="token operator">=</span> init_detector<span class="token punctuation">(</span>config_file<span class="token punctuation">,</span> checkpoint_file<span class="token punctuation">,</span> device<span class="token operator">=</span>device<span class="token punctuation">)</span><span class="token comment"># 推理演示图像</span>img <span class="token operator">=</span> <span class="token string">'demo/demo.jpg'</span>result <span class="token operator">=</span> inference_detector<span class="token punctuation">(</span>model<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token comment"># 绘制结果图</span>model<span class="token punctuation">.</span>show_result<span class="token punctuation">(</span>img<span class="token punctuation">,</span> result<span class="token punctuation">,</span> wait_time<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> OpenMMLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
            <tag> MMDetection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猫头鹰先生催眠录音文本</title>
      <link href="/archives/11812369.html"/>
      <url>/archives/11812369.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV16f4y1S72h">bilibili link</a></p><p>my name is Mr. Owl</p><p>I will shortly lead you through a guided hypnosis</p><p>please don’t listen to this while driving or operating machinery</p><p>you may also want to have a glass of water nearby</p><p>it can help ground you after a recession</p><p>I would like you to start by simply lying down in a comfortable position </p><p>perhaps on some cushions</p><p>or on a couch</p><p>and just take a few moments to relax your mind</p><p>(a moment …)</p><p>in a moment</p><p>I’m going to ask you to imagine a place</p><p>a special place</p><p>you may see it</p><p>feel it</p><p>imagine it or experience it</p><p>in any way you want</p><p>and you might find your mind wondering quite a bit</p><p>but that doesn’t matter to you</p><p>the sound of my voice will continue to relax you</p><p>and it doesn’t matter if you don’t hear a word I say</p><p>because very soon now</p><p>you are going to be relaxed</p><p>more than you have ever known</p><p>imagine now that you are in that place</p><p>that place you know well</p><p>a hotel by a lake</p><p>and you are here </p><p>at the top of a gorgeous staircase</p><p>in a large open hallway</p><p>a really beautiful old hotel</p><p>it’s such a comfortable temperature here</p><p>daylight streams in through the window</p><p>slightly warm</p><p>such a peaceful place to be</p><p>and at the bottom of those stairs</p><p>an open doorway</p><p>leading to a garden</p><p>in a few moments</p><p>I will count</p><p>from 1 to 10</p><p>and count you down each step</p><p>let each number</p><p>represent a step</p><p>and each step takes you deeper and deeper</p><p>into relaxation</p><p>so that by the time I get to ten</p><p>you can allow yourself</p><p>to be as deeply relaxed</p><p>as you ever can be</p><p>and you’ll still hear</p><p>the sound of my voice</p><p>and as you look down</p><p>you can glimpse</p><p>through the open door</p><p>that intriguing garden</p><p>it’s so interesting to you</p><p>to explore and discover</p><p>this special place</p><p>the sunlight to the windows on your skin</p><p>there’s no one around</p><p>that needs anything from you</p><p>no one around</p><p>to bother you</p><p>1</p><p>when you are ready</p><p>take your first step now</p><p>relaxing letting go</p><p>2</p><p>take another step</p><p>feeling more at ease</p><p>and at peace with yourself</p><p>3</p><p>perhaps noticing</p><p>heavy</p><p>restful feeling</p><p>spreading down your legs</p><p>with every step</p><p>4</p><p>just drifting deeper</p><p>and deeper down</p><p>5</p><p>another step</p><p>becoming calmer</p><p>and even calmer still</p><p>continuing to relax</p><p>continuing to let go</p><p>and feeling so good</p><p>6</p><p>perhaps beginning to notice</p><p>any sounds becoming part of your experience of comfort</p><p>relaxation</p><p>and anything you notice</p><p>becoming part of your experience</p><p>7</p><p>sinking deeper and deeper</p><p>drifting</p><p>further</p><p>into this welcoming</p><p>relaxed state</p><p>8</p><p>enjoying those feelings</p><p>half awake</p><p>half asleep</p><p>9</p><p>noticing way of growing relaxation</p><p>and spreading comfort</p><p>10</p><p>an now</p><p>at the bottom of the stairs</p><p>and wandering through that open door</p><p>how into the gardon beyond</p><p>soak up those feelings of</p><p>tranquility</p><p>see</p><p>hear</p><p>feel sense or imagine this</p><p>beautiful garden</p><p>the greens</p><p>the flowers</p><p>the trees</p><p>the brown</p><p>the clear blue sky</p><p>feel the warmth of the sun</p><p>on your head and shoulders</p><p>enjoy a moment here</p><p>and peace</p><p>inhale the sense of the garden</p><p>there is no one around</p><p>wanting anything from you</p><p>needing anything from you</p><p>no one expecting anything</p><p>so enjoy this</p><p>peace</p><p>and quiet</p><p>for a few moments more</p><p>notice now</p><p>at the end of this garden</p><p>a set of steps</p><p>leading down to a sturdy pier</p><p>at the edge of lake</p><p>so now</p><p>take the steps now</p><p>sinking further and further into relaxation</p><p>as you do</p><p>more and more relaxed with each step</p><p>until you step onto the wooden pier</p><p>then stepping forward</p><p>towards that beautiful crystal blue water</p><p>the sun on your skin</p><p>and gentle breeze</p><p>and here</p><p>at the end of the pier</p><p>a fishing rod</p><p>You take it in your hand</p><p>feel a comforting weight of it</p><p>not too heavy to hold</p><p>but you know that it’s strong and sturdy</p><p>it will not struggle with the weight of today’s catch</p><p>slowly and deliberately</p><p>you unravel some of the line</p><p>you pull back the rod</p><p>and cast that line into that crystal</p><p>clear</p><p>blue water</p><p>it sits in that water for a moment</p><p>and soon you feel a gentle pull on the fishing rod</p><p>you’ve caught something</p><p>you gently crank back the handle</p><p>pulling your catch out of the water</p><p>what have you caught</p><p>it’s a white cube</p><p>so square and perfect on every side</p><p>a little water drips from it</p><p>as you gently swing it back onto the pier beside you</p><p>you lower the fishing rod to your side</p><p>and you take</p><p>the white cube from the line</p><p>what’s inside this cube</p><p>it’s a memory</p><p>a good memory</p><p>a memory from your life</p><p>a memory of a time when you were happy</p><p>and strong</p><p>and confident</p><p>you pick up the cube</p><p>you hold it close to your face</p><p>and now you can see this memory</p><p>you see it in a vivid wide screen</p><p>The colors are rich</p><p>the image is bright</p><p>the sound is clear and strong and vibrant</p><p>so strong and vibrant that you step into this memory</p><p>you are inside</p><p>let those feelings grow inside you</p><p>feeling happy and strong and confident and bright</p><p>take a moment to enjoy this</p><p>to live in it</p><p>to breathe</p><p>this beautiful positive memory from the white cube</p><p>feeling strong and confident</p><p>and bright and happy</p><p>now</p><p>slowly</p><p>and with care</p><p>you move out of the memory</p><p>and you lower the cube</p><p>from in front of your face</p><p>and se t it down gently on the pier beside you</p><p>take a moment now</p><p>look out</p><p>onto the lake</p><p>at the cool blue water</p><p>the peace</p><p>tranquility of it</p><p>you kneel down and lower the white cube</p><p>into the peaceful water</p><p>and as the ripples slow and stop</p><p>you catch sight of your own reflection</p><p>and you see how beautiful you are</p><p>how strong you are</p><p>you can see positivity in your eye</p><p>like jewels</p><p>you stand and look out at that lake</p><p>calm serene and full of power</p><p>breathe it in gently</p><p>and then breathe it out gently</p><p>all that power that’s within you</p><p>I let you enjoy those feelings for a few moments more</p><p>allow you time to bask in that life</p><p>but soon</p><p>soon I’ll start count from one up to five</p><p>when I reach five</p><p>you will be back in the room</p><p>1</p><p>starting to come back</p><p>become aware of your breathing</p><p>your body and the space around you</p><p>2</p><p>moving your legs start to wiggle your toes and feet</p><p>a lovely grounding energy, traveling up your legs</p><p>3</p><p>moving your arms starting to stretch, feel the energy moving through your body again</p><p>4 </p><p>your eyes starting to open</p><p>And on the next count your eyes fully open </p><p>5</p><p>eyes fully open, feeling refreshed and recharged and being fully aware of being in the space</p><p>welcome back</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 催眠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校友访谈(纪录片)培训</title>
      <link href="/archives/c8ed5799.html"/>
      <url>/archives/c8ed5799.html</url>
      
        <content type="html"><![CDATA[<h1 id="校友访谈-纪录片-培训"><a href="#校友访谈-纪录片-培训" class="headerlink" title="校友访谈(纪录片)培训"></a>校友访谈(纪录片)培训</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>认识纪录片和口述史</p><p>什么是真实，什么是好的纪录片</p></li><li><p>没有绝对的真实，让故事有逻辑，人物有发展，让观众感到真实，是一个好的纪录片的条件</p></li></ol><h2 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h2><ol><li>个人维度：生平，行业信息，突出成就，家庭情况</li><li>历史维度：经历过哪些重大的历史事件，与其他人物在历史上的交集</li><li>事件叙述：起因，过程，结果，历史意义</li><li>最终形成一个人物小传</li></ol><h3 id="案例分享《南大创业者的时代脉搏》"><a href="#案例分享《南大创业者的时代脉搏》" class="headerlink" title="案例分享《南大创业者的时代脉搏》"></a>案例分享《南大创业者的时代脉搏》</h3><h2 id="故事撰写"><a href="#故事撰写" class="headerlink" title="故事撰写"></a>故事撰写</h2><ol><li>一句话概括你的故事 logline</li><li>故事的介绍与结构，关于影片的故事结构，开头、过程、结尾、重要节点</li><li>人物的塑造需要有成长，有套路，从平凡到不平凡的循环过程</li></ol><h2 id="撰写采访问题"><a href="#撰写采访问题" class="headerlink" title="撰写采访问题"></a>撰写采访问题</h2><ol><li>撰写问题按照时间线的顺序，帮助被采访人回忆</li><li>有必须完成的固定动作：重要历程的回顾，重要时间点的讲述，关于主题的必然联系，所有人都希望被理解、被尊重</li><li><p>固定动作之外的惊喜问题：有一些尖锐深刻的话题，在心里拟定好，在现场找点切入</p></li><li><p>多人物采访时的问题思路：采访者之间的共性、特性问题，以及相应的惊喜问题</p></li></ol><h2 id="确定视觉与文字展现形式"><a href="#确定视觉与文字展现形式" class="headerlink" title="确定视觉与文字展现形式"></a>确定视觉与文字展现形式</h2><ol><li>阐述式：有旁白、有采访</li><li>观察式：观察人物</li><li>参与式：类似于 互动vlog</li><li>扮演式：找演员扮演</li><li>资料式：用资料和人物还原</li><li>动画纪录片</li></ol><p>阐述 + 资料为常见组合</p><h2 id="现场拍摄"><a href="#现场拍摄" class="headerlink" title="现场拍摄"></a>现场拍摄</h2><p>摄像机、三脚架、话筒、灯</p><p>注意事项：</p><ol><li>受访者知晓拍摄内容、用途、签文件</li><li>调整环境，让受访者感到舒适，但同时可能需要牺牲画质</li><li>开始前先聊聊家常，同时调整声音和构图，调整画面水平</li><li>采访时，一定不要打断受访者，始终保持眼神交流，不要使用语气词“嗯，啊”之类的</li><li>随即调整采访的顺序</li></ol><h2 id="跟拍"><a href="#跟拍" class="headerlink" title="跟拍"></a>跟拍</h2><ol><li>镜头稳定</li><li>镜头表现</li><li>素材保管，一定要双备份，甚至三备份！因为素材是很“贵”的，不要用剪切！</li><li>保持“记录感”，让镜头持续开机，有比没有强</li></ol><h2 id="Transcription-amp-paper-cut"><a href="#Transcription-amp-paper-cut" class="headerlink" title="Transcription &amp; paper cut"></a>Transcription &amp; paper cut</h2><ol><li>将视频中的文字对话导出</li><li>完成影片脚本，这个脚本是剪辑的根据与逻辑</li></ol><h2 id="剪辑与后期"><a href="#剪辑与后期" class="headerlink" title="剪辑与后期"></a>剪辑与后期</h2><ol><li>剪辑主要故事线</li><li>增加资料、素材、特效包装</li><li>声音制作、调色</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪录片 </tag>
            
            <tag> 培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda 笔记</title>
      <link href="/archives/c8895fc.html"/>
      <url>/archives/c8895fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Conda-Cheat-Sheet"><a href="#Conda-Cheat-Sheet" class="headerlink" title="Conda Cheat Sheet"></a>Conda Cheat Sheet</h1><p>记录一些常用的 conda 命令帮助快速管理环境，整理自官方 <a href="https://docs.conda.io/projects/conda/en/4.6.0/_downloads/52a95608c49671267e40c689e0bc00ca/conda-cheatsheet.pdf">CONDA CHEAT SHEET</a></p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="conda-info"><a href="#conda-info" class="headerlink" title="conda info"></a>conda info</h3><p>这个命令非常管用，基本上能够看到所有的 conda 配置信息</p><h3 id="conda-install"><a href="#conda-install" class="headerlink" title="conda install"></a>conda install</h3><p><code>conda install PACKAGENAME</code> 下载指定包</p><h3 id="conda-update"><a href="#conda-update" class="headerlink" title="conda update"></a>conda update</h3><p><code>conda update PACKAGENAME</code> 更新指定包 </p><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><h3 id="conda-create-n"><a href="#conda-create-n" class="headerlink" title="conda create -n"></a>conda create -n</h3><p><code>conda create -n py36 python=3.6</code> 创造一个 python 3.6 的环境 py36</p><p>注意：一般都要加上 <code>python=x.x</code> 否则使用的是 base 环境的 python 解释器</p><h3 id="conda-env-list"><a href="#conda-env-list" class="headerlink" title="conda env list"></a>conda env list</h3><p>列出目前有的环境</p><h3 id="conda-env-remove"><a href="#conda-env-remove" class="headerlink" title="conda env remove"></a>conda env remove</h3><p><code>conda env remove -n env_name</code> 移除环境</p><h3 id="conda-activate-deactivate"><a href="#conda-activate-deactivate" class="headerlink" title="conda activate/deactivate"></a>conda activate/deactivate</h3><p><code>conda activate/deactivate env_name</code> 激活/退出环境</p><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><h3 id="conda-install-1"><a href="#conda-install-1" class="headerlink" title="conda install"></a>conda install</h3><p><code>conda install PACKAGENAME</code> 下载包</p><p><code>conda install --file requirements.txt</code> 通过 requirements 文件下载包</p><h3 id="conda-remove"><a href="#conda-remove" class="headerlink" title="conda remove"></a>conda remove</h3><p><code>conda remove PACKAGENAME</code> 移除包</p><h3 id="conda-list"><a href="#conda-list" class="headerlink" title="conda list"></a>conda list</h3><p><code>conda list PACKAGENAME</code> 查看环境的某个包，如果不加 PACKAGENAME 则列出所有环境</p><h3 id="conda-clean"><a href="#conda-clean" class="headerlink" title="conda clean"></a>conda clean</h3><p>如果不清理的话，anaconda 还是很吃存储的，会逐渐积累很多下载包</p><p><code>conda clean --all</code>  Remove index cache, lock files, unused cache packages, and tarballs.</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="禁用自动启动-base-环境"><a href="#禁用自动启动-base-环境" class="headerlink" title="禁用自动启动 base 环境"></a>禁用自动启动 base 环境</h3><p>每次打开新的 shell 都会自动进入 base 环境，用下面的命令行禁用</p><p><code>conda config --set auto_activate_base false</code></p><h3 id="镜像源设置"><a href="#镜像源设置" class="headerlink" title="镜像源设置"></a>镜像源设置</h3><p>编辑 <code>~/.condarc</code> 文件，设置镜像源</p><p><a href="https://mirrors.bfsu.edu.cn/help/anaconda/">北外镜像源官方帮助文档</a></p><pre class="line-numbers language-.condarc" data-language=".condarc"><code class="language-.condarc">channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud  msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud  bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud  menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud  pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud  simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> conda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manim 教程</title>
      <link href="/archives/5654e2fe.html"/>
      <url>/archives/5654e2fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="Manim-note"><a href="#Manim-note" class="headerlink" title="Manim note"></a>Manim note</h1><p>官方 <a href="https://github.com/3b1b/manim">github 项目</a></p><blockquote><p>Note, there are two versions of manim. This repository began as a personal project by the author of <a href="https://www.3blue1brown.com/">3Blue1Brown</a> for the purpose of animating those videos, with video-specific code available <a href="https://github.com/3b1b/videos">here</a>. In 2020 a group of developers forked it into what is now the <a href="https://github.com/ManimCommunity/manim/">community edition</a>, with a goal of being more stable, better tested, quicker to respond to community contributions, and all around friendlier to get started with. See <a href="https://docs.manim.community/en/stable/installation/versions.html?highlight=OpenGL#which-version-to-use">this page</a> for more details.</p></blockquote><p>这里提到有两个版本的 manim，推荐使用 community edition，这个版本更稳定，更容易上手，下面是两个参考链接</p><ol><li><p><a href="https://github.com/ManimCommunity/manim/">ManimCE github</a></p></li><li><p><a href="https://www.manim.community/">ManimCE documentation</a></p></li></ol><p>强烈推荐根据官方文档进行学习，因为网上的很多资源都是过时的，包括我这篇笔记也会可能会很快过时。这篇笔记主要记录如何安装 ManimCE，以及其代码逻辑，更多实用的动画方法另外再做整理。</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><h3 id="Install-dependencies"><a href="#Install-dependencies" class="headerlink" title="Install dependencies"></a>Install dependencies</h3><p>官方给出了一个<a href="https://hub.gke2.mybinder.org/user/behackl-725d956-b7bf9b4aef40b78-cns6ckcq/notebooks/basic%20example%20scenes.ipynb"> jupyter notebook</a> 预先装载好了 manim 环境，如果你现在不想安装的话，可以在这个 notebook 里面进行小实验</p><p>ManimCE 需要预先下载两个软件 ffmpeg 和 LaTex。文档中建议使用 Scoop, Chocolatey 等包管理软件来下载 dependencies，但我太懒了，不想再下一个包管理软件，而且我自己的电脑上本来就安装了 LaTex 和 ffmpeg 所以只要确保 ManimCE  能够调用这些 dependencies 即可，具体来说就是让 ffmpeg 和 LaTex 命令加入环境变量</p><p>给两个参考链接：<a href="https://zhuanlan.zhihu.com/p/118362010">ffmpeg 知乎教程</a>  <a href="https://www.bilibili.com/video/BV11h41127FD?from=search&amp;seid=5330798070960440671">LaTex简介 bilibili</a></p><p>最后在命令行窗口输入 <code>ffmpeg -version</code> 和  <code>tex -version</code> 检查看看能否成功运行</p><h3 id="Install-ManimCE"><a href="#Install-ManimCE" class="headerlink" title="Install ManimCE"></a>Install ManimCE</h3><blockquote><p>Manim Community runs on Python 3.7+. If you’d like to just use the library, you can install it from PyPI via pip:</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pip <span class="token function">install</span> manim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为习惯了用 conda，所以我选择在 conda 中创建一个 Manim 环境，然后再 pip install</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">conda create -n manim <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(然而最终却稀里糊涂的安装在了 base 环境)</p><p>使用 <code>conda list manim</code> 检查是否安装成功，通过 <a href="https://docs.manim.community/en/stable/tutorials/quickstart.html">Quickstart</a> 简单运行一个程序，检查整个流程是否能够运行</p><h2 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h2><h3 id="Quickstart"><a href="#Quickstart" class="headerlink" title="Quickstart"></a>Quickstart</h3><p>下面是一段简单的代码，能够实现从矩形到圆形的变换</p><p><img src="/archives/5654e2fe/SquareToCircle_ManimCE_v0.8.0.gif" alt="SquareToCircle_ManimCE_v0.8.0" style="zoom: 25%;"></p><p>代码如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># scene.py</span><span class="token keyword">from</span> manim <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">class</span> <span class="token class-name">SquareToCircle</span><span class="token punctuation">(</span>Scene<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">construct</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        circle <span class="token operator">=</span> Circle<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># create a circle</span>        circle<span class="token punctuation">.</span>set_fill<span class="token punctuation">(</span>PINK<span class="token punctuation">,</span> opacity<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>  <span class="token comment"># set color and transparency</span>        square <span class="token operator">=</span> Square<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># create a square</span>        square<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>PI <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment"># rotate a certain amount</span>        self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>Create<span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># animate the creation of the square</span>        self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>Transform<span class="token punctuation">(</span>square<span class="token punctuation">,</span> circle<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># interpolate the square into the circle</span>        self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>FadeOut<span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># fade out animation</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 terminal 中执行文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">manim -pql scene.py SquareToCircle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从上面的代码能够看出 Manim 的一些基本框架，首先要有 class 类别作为场景 Scene，在这个 class 中定义 construct() 函数来实现动画效果，然后通过命令行渲染出动画。文档中提到的 Tip:</p><blockquote><p>Every animation must be contained within the <a href="https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html#manim.scene.scene.Scene.construct"><code>construct()</code></a> method of a class that derives from <a href="https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html#manim.scene.scene.Scene"><code>Scene</code></a>. Other code, for example auxiliary or mathematical functions, may reside outside the class.</p></blockquote><h3 id="A-deeper-look"><a href="#A-deeper-look" class="headerlink" title="A deeper look"></a>A deeper look</h3><p>主要来分析一下上面的命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">manim -pql scene.py SquareToCircle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文档中解释</p><blockquote><p>First, this command executes manim on the file <code>scene.py</code>, which contains our animation code. Further, this command tells manim exactly which <code>Scene</code> is to be rendered, in this case, it is <code>SquareToCircle</code>. This is necessary because a single scene file may contain more than one scene. Next, the flag -p tells manim to play the scene once it’s rendered, and the -ql flag tells manim to render the scene in low quality.</p></blockquote><p>下面是几个常见的参数：</p><ol><li><code>-ql, -qm, -qh, -qk</code> 分别代表不同分辨率，从低到高，再到4k</li><li><code>-a</code> 渲染所有的 Scene</li><li><code>-i</code> 输出为 gif 格式</li><li><code>-f</code> 渲染完成后打开所在文件夹</li></ol><h3 id="Manim’s-building-blocks"><a href="#Manim’s-building-blocks" class="headerlink" title="Manim’s building blocks"></a>Manim’s building blocks</h3><p>Manim 中有3个重要概念</p><ol><li><strong>mathematical object</strong> (or <strong>mobject</strong> for short)</li><li><strong>animation</strong></li><li><strong>scene</strong>.</li></ol><blockquote><p>As we will see in the following sections, each of these three concepts is implemented in manim as a separate class: the <a href="https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html#manim.mobject.mobject.Mobject"><code>Mobject</code></a>, <a href="https://docs.manim.community/en/stable/reference/manim.animation.animation.Animation.html#manim.animation.animation.Animation"><code>Animation</code></a>, and <a href="https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html#manim.scene.scene.Scene"><code>Scene</code></a> classes.</p></blockquote><h4 id="Mobject"><a href="#Mobject" class="headerlink" title="Mobject"></a>Mobject</h4><blockquote><p>Any object that can be displayed on the screen is a <code>mobject</code>, even if it is not necessarily <em>mathematical</em> in nature.</p></blockquote><p>通过 scene 类中的方法 add(), remove() 来在场景中加入 mobject</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> manim <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">class</span> <span class="token class-name">CreatingMobjects</span><span class="token punctuation">(</span>Scene<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">construct</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        circle <span class="token operator">=</span> Circle<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>circle<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>circle<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 mobject 属性的调整，是通过调 mobject 类的方法来完成</p><ol><li><p>Placing mobject location. 选择在哪里加入物体</p><p>.shift()  .move_to()  .next_to()  .align_to()</p></li><li><p>Styling mobjects. 对物体进行风格渲染</p><p>.set_stroke()  .set_fill()</p></li><li><p>Mobject on-screen order. 添加入场景的 mobject 是有顺序的，后添加的物体会覆盖到图层的上方</p></li></ol><h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><blockquote><p>At the heart of manim is animation. Generally, you can add an animation to your scene by calling the <code>play()</code> method.</p></blockquote><p>一般来讲通过 play() 方法来加入动画</p><blockquote><p>Animations are procedures that interpolate between two mobjects.</p></blockquote><p>动画的基本原理可以理解为，使用不同的函数在两个关键帧之间进行插值，然后使用 play() 方法进行播放，比如在 Quickstart 中的动画</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>Create<span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># animate the creation of the square</span>self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>Transform<span class="token punctuation">(</span>square<span class="token punctuation">,</span> circle<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># interpolate the square into the circle</span>self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>FadeOut<span class="token punctuation">(</span>square<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># fade out animation</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只要可变的属性，都可以使用动画，通过 <code>Mobject.aminate</code> 实现</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> manim <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">class</span> <span class="token class-name">ApplyMethodExample</span><span class="token punctuation">(</span>Scene<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">construct</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        square <span class="token operator">=</span> Square<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_fill<span class="token punctuation">(</span>RED<span class="token punctuation">,</span> opacity<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>square<span class="token punctuation">)</span>        <span class="token comment"># animate the change of color</span>        self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>square<span class="token punctuation">.</span>animate<span class="token punctuation">.</span>set_fill<span class="token punctuation">(</span>WHITE<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># animate the change of position</span>        self<span class="token punctuation">.</span>play<span class="token punctuation">(</span>square<span class="token punctuation">.</span>animate<span class="token punctuation">.</span>shift<span class="token punctuation">(</span>UP<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/archives/5654e2fe/ApplyMethodExample_ManimCE_v0.8.0.gif" alt="ApplyMethodExample_ManimCE_v0.8.0" style="zoom: 25%;"></p><h4 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h4><blockquote><p>The <a href="https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html#manim.scene.scene.Scene"><code>Scene</code></a> class is the connective tissue of manim. </p></blockquote><p>所有的 mobject 和 animation 都必须加入到 scene 中才能被展现出来，并且 scene 中必须包含 construct() 方法</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><blockquote><p>Manim provides an extensive configuration system that allows it to adapt to many different use cases. There are many configuration options that can be configured at different times during the scene rendering process. </p></blockquote><p>在渲染动画的过程中还可以设置更多的参数，比如视频渲染质量的高低 <code>-ql, -qh</code></p><p>能够设置 Configuration 的方法有几种</p><ol><li><p>The ManimConfig class</p><blockquote><p>The most direct way of configuring manim is via the global <code>config</code> object, which is an instance of <a href="https://docs.manim.community/en/stable/reference/manim._config.utils.ManimConfig.html#manim._config.utils.ManimConfig"><code>ManimConfig</code></a>.</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> manim <span class="token keyword">import</span> <span class="token operator">*</span>config<span class="token punctuation">.</span>background_color <span class="token operator">=</span> WHITEconfig<span class="token punctuation">[</span><span class="token string">"background_color"</span><span class="token punctuation">]</span> <span class="token operator">=</span> WHITE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Command-line arguments</p><blockquote><p>The following example specifies the output file name (with the <code>-o</code> flag), renders only the first ten animations (<code>-n</code> flag) with a white background (<code>-c</code> flag), and saves the animation as a .gif instead of as a .mp4 file (<code>-i</code> flag). It uses the default quality and does not try to open the file after it is rendered.</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">manim -o myscene -i -n <span class="token number">0,10</span> -c WHITE <span class="token operator">&lt;</span>file.py<span class="token operator">&gt;</span> SceneName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>The config files</p><blockquote><p>Manim can also be configured using a configuration file. A configuration file is a file ending with the suffix <code>.cfg</code>. To use a configuration file when rendering your scene, you must create a file with name <code>manim.cfg</code> in the same directory as your scene code.</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>CLI<span class="token punctuation">]</span><span class="token comment"># my config file</span>output_file <span class="token operator">=</span> myscenesave_as_gif <span class="token operator">=</span> <span class="token boolean">True</span>background_color <span class="token operator">=</span> WHITE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="Using-Text"><a href="#Using-Text" class="headerlink" title="Using Text"></a>Using Text</h3><p>There are two different ways by which you can render <strong>Text</strong> in videos:</p><ol><li>Using Pango (<a href="https://docs.manim.community/en/stable/reference/manim.mobject.svg.text_mobject.html#module-manim.mobject.svg.text_mobject"><code>text_mobject</code></a>)</li><li>Using LaTeX (<a href="https://docs.manim.community/en/stable/reference/manim.mobject.svg.tex_mobject.html#module-manim.mobject.svg.tex_mobject"><code>tex_mobject</code></a>)</li></ol><p>一般如果不用公式的话，直接使用 text_mobject 就可以了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> manim <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">(</span>Scene<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">construct</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>                text <span class="token operator">=</span> Text<span class="token punctuation">(</span><span class="token string">'Hello world'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>scale<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/archives/5654e2fe/image-20210729160507790.png" style="zoom:25%;"></p><p>使用 tex_mobject 的话，如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> manim <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">class</span> <span class="token class-name">HelloLaTeX</span><span class="token punctuation">(</span>Scene<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">construct</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>                tex <span class="token operator">=</span> Tex<span class="token punctuation">(</span><span class="token string">r"\LaTeX"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>scale<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tex<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/archives/5654e2fe/image-20210729160532548.png" style="zoom: 33%;"></p><p>注意需要使用 raw string <code>r('...')</code> 因为 Latex 中很多特殊字符需要进行转义</p><p>还有不同的方法都能返回 text_mobject &amp; tex_mobject，比如 MarkupText, MathTex </p><p>这篇笔记就到这里了，还有好多好玩的功能就请自行探索吧 😎</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manim </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster RCNN 笔记</title>
      <link href="/archives/2ad8fafc.html"/>
      <url>/archives/2ad8fafc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Faster-RCNN-note"><a href="#Faster-RCNN-note" class="headerlink" title="Faster RCNN note"></a>Faster RCNN note</h1><p>本文总结自知乎链接<a href="https://zhuanlan.zhihu.com/p/31426458">https://zhuanlan.zhihu.com/p/31426458</a></p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>Faster RCNN其实可以分为4个主要内容：</p><ol><li><p>Conv layers </p><p>Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</p></li><li><p>Region Proposal Networks</p><p>该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。</p></li><li><p>Roi Pooling</p><p>该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</p></li><li><p>Classification</p><p>利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</p></li></ol><p><img src="/archives/2ad8fafc/image-20210614151135341.png" style="zoom: 67%;"></p><h2 id="Conv-Layers"><a href="#Conv-Layers" class="headerlink" title="Conv Layers"></a>Conv Layers</h2><p>Conv layers部分共有13个conv层，13个relu层，4个pooling层 </p><ol><li>所有的conv层都是：kernel_size=3，pad=1，stride=1</li><li>所有的pooling层都是：kernel_size=2，pad=0，stride=2</li></ol><p>那么，一个MxN大小的矩阵经过Conv layers固定变为(M/16)x(N/16)</p><h2 id="Region-Proposal-Networks"><a href="#Region-Proposal-Networks" class="headerlink" title="Region Proposal Networks"></a>Region Proposal Networks</h2><h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><p>提到RPN网络，就不能不说anchors。所谓anchors，实际上就是一组由程序生成的矩形。直接运行作者demo中的generate_anchors.py可以得到以下输出 (不要被这些数字吓到了，没有具体意义)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span><span class="token number">84</span><span class="token punctuation">.</span>  <span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">.</span>   <span class="token number">99</span><span class="token punctuation">.</span>   <span class="token number">55</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">176</span><span class="token punctuation">.</span>  <span class="token operator">-</span><span class="token number">88</span><span class="token punctuation">.</span>  <span class="token number">191</span><span class="token punctuation">.</span>  <span class="token number">103</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">360</span><span class="token punctuation">.</span> <span class="token operator">-</span><span class="token number">184</span><span class="token punctuation">.</span>  <span class="token number">375</span><span class="token punctuation">.</span>  <span class="token number">199</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token operator">-</span><span class="token number">56</span><span class="token punctuation">.</span>  <span class="token operator">-</span><span class="token number">56</span><span class="token punctuation">.</span>   <span class="token number">71</span><span class="token punctuation">.</span>   <span class="token number">71</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">120</span><span class="token punctuation">.</span> <span class="token operator">-</span><span class="token number">120</span><span class="token punctuation">.</span>  <span class="token number">135</span><span class="token punctuation">.</span>  <span class="token number">135</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">248</span><span class="token punctuation">.</span> <span class="token operator">-</span><span class="token number">248</span><span class="token punctuation">.</span>  <span class="token number">263</span><span class="token punctuation">.</span>  <span class="token number">263</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token operator">-</span><span class="token number">36</span><span class="token punctuation">.</span>  <span class="token operator">-</span><span class="token number">80</span><span class="token punctuation">.</span>   <span class="token number">51</span><span class="token punctuation">.</span>   <span class="token number">95</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token operator">-</span><span class="token number">80</span><span class="token punctuation">.</span> <span class="token operator">-</span><span class="token number">168</span><span class="token punctuation">.</span>   <span class="token number">95</span><span class="token punctuation">.</span>  <span class="token number">183</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">168</span><span class="token punctuation">.</span> <span class="token operator">-</span><span class="token number">344</span><span class="token punctuation">.</span>  <span class="token number">183</span><span class="token punctuation">.</span>  <span class="token number">359</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每行有4个值，代表了矩形左上角和右下角两个点$(x_1, y_1, x_2, y_2)$ </p><p>一共9个矩形，来组于不同长宽比和不同大小的组合：长宽比有3种，1:1, 1:2, 2:1</p><p><img src="/archives/2ad8fafc/image-20210614152512944.png" style="zoom:50%;"></p><p>那么这9个anchors是做什么的呢？借用Faster RCNN论文中的原图，如图7，遍历Conv layers计算获得的feature maps，为每一个点都配备这9种anchors作为初始的检测框</p><p><img src="/archives/2ad8fafc/v2-c93db71cc8f4f4fd8cfb4ef2e2cef4f4_720w.jpg" style="zoom:80%;"></p><p>简单解释一下上图：</p><ol><li><p>conv feature map中，每一个点都是256-dimensions</p></li><li><p>intermidiate layer为 3x3 卷积，out put dimension为256，得到新的conv feature map</p></li><li><p>在新的conv feature map上，我们对每一个点预先设定的k个anchor做bounding box regression和softmax分类(positive, nagetive两类)，分别对应4k coordinates，2k scores</p><p>换句话说，就是把某一anchor区域中的特征向量拿去做prediction，预测内容为该点的分类和该点/anchor对应的bounding box参数</p></li><li><p>由于anchor数量是巨大的，训练程序会在合适的anchors中<strong>随机</strong>选取128个postive anchors+128个negative anchors进行训练</p></li></ol><h3 id="Bounding-box-regression原理"><a href="#Bounding-box-regression原理" class="headerlink" title="Bounding box regression原理"></a>Bounding box regression原理</h3><p>怎样在anchor的基础上回归得到ground truth标签呢？</p><p>给定anchor $(A_x, A_y, A_w, A_h)$ ，给定ground truth $(G_x, G_y, G_w, G_h)$</p><p>我们只要去预测中心点的位置偏移，以及矩形长宽的缩放即可</p><p>个人觉得这样的回归方法有点麻烦，这样来看CenterNet中的bounding box回归是相当直接的</p><h3 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h3><ol><li>生成anchors，得到对应的confidence score &amp; bounding box regression，形成最初的proposal</li><li>对所有anchors，根据positive score进行排序，取前6000个anchor proposals</li><li>去除较小和超出边界的proposal</li><li>NMS</li></ol><h2 id="ROI-Pooling"><a href="#ROI-Pooling" class="headerlink" title="ROI Pooling"></a>ROI Pooling</h2><p>Rol pooling层有2个输入：</p><ol><li>原始feature maps</li><li>RPN输出的proposals</li></ol><p>这一个Pooling操作还要有一个功能，就是需要处理不同大小的proposal (kernel)。经典的pooing操作是使用相同大小的kernel，这里我们要预先对 proposal (region of interest) 进行统一的分割，使得pooling结果是相同的表示(如下图)</p><p><img src="/archives/2ad8fafc/image-20210614164103022.png" style="zoom: 67%;"></p><h2 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h2><p>Classification部分利用已经获得的proposal feature maps，通过full connect层与softmax计算每个proposal具体属于那个类别（如人，车，电视等），输出cls_prob概率向量；同时再次利用bounding box regression获得每个proposal的位置偏移量bbox_pred，用于回归更加精确的目标检测框</p><p><img src="/archives/2ad8fafc/image-20210614164211554.png" style="zoom:80%;"></p><h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p>Faster R-CNN的训练，是在已经训练好的model（如VGG，ZF）的基础上继续进行训练，实际训练过程为以下：</p><ol><li>在已经训练好的model(e.g. VGG)，训练RPN</li><li>用步骤1中得到的RPN提出proposal</li><li>用提出的Proposal训练Fast RCNN</li><li>用步骤4中训练好的Fast RCNN继续训练RPN</li><li>重复2</li><li>重复3</li></ol><p>可以看出这是一种类似迭代的过程，但只循环了2次，文章提出更多的循环并不会带来相应的提升</p>]]></content>
      
      
      <categories>
          
          <category> papers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> faster rcnn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs code 教程</title>
      <link href="/archives/ca50f614.html"/>
      <url>/archives/ca50f614.html</url>
      
        <content type="html"><![CDATA[<h1 id="VS-Code-note"><a href="#VS-Code-note" class="headerlink" title="VS Code note"></a>VS Code note</h1><p>学习视频 <a href="https://www.bilibili.com/video/BV1ty4y1S7mC?p=1">bilibili</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接在官网一键下载，宇宙第一开发工具，而且还是免费的<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h3><ol><li><p>vs code 支持更换主题皮肤</p></li><li><p>vs code 支持插件扩展，能够实现多种功能来提高编程效率，如下载不同语言，高亮代码等等</p></li><li><p>通过快捷键 palette 查找文件 Ctrl + P，查找命令 Ctrl + Shift + P</p><p>可以修改一些你常用命令的快捷键，我修改了如下命令：</p><ol><li>Run in python file: Ctrl + enter</li><li>Start debugging: Ctrl + shift +enter</li><li>Close panels: Ctrl + Alt + P</li></ol></li><li><p>设置面板快捷键 Ctrl + ,</p></li><li><p>新建一个文件 Ctrl + N</p></li></ol><h2 id="交互式演练场-Interactive-Playground"><a href="#交互式演练场-Interactive-Playground" class="headerlink" title="交互式演练场 Interactive Playground"></a>交互式演练场 Interactive Playground</h2><p>一些编辑的小技巧</p><ol><li><p>同时选中同名字段 Ctrl + Shift + L，但这个功能没有 Refactoring 智能</p></li><li><p>IntelliSense 自动补全 api 功能 Ctrl + space</p></li><li><p>行操作</p><ol><li>复制行，在没有任何东西选中的时候直接 Ctrl + C</li><li>上下移动行，Alt + 上下键</li><li>删除行 Ctrl + Shift + K</li></ol></li><li><p>Formatting 规范代码，需要自己定义 format</p></li></ol><h2 id="一些推荐的设置"><a href="#一些推荐的设置" class="headerlink" title="一些推荐的设置"></a>一些推荐的设置</h2><p>打开 settings</p><ol><li>在熟悉之后关闭 welcome/startup 界面</li><li>建议使用英文界面</li><li>设置字体 JetBrains Mono，还可以顺便设置一下字号。安装字体<a href="https://blog.csdn.net/HUSTHY/article/details/104023077">教程</a></li><li>设置是否显示缩略图 minimap</li><li>设置 restore windows 是否直接恢复上一次的项目</li><li>设置开启 Trims final newlines 自动消除文件末尾多余的空行</li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>下载 Python 插件</p><h3 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h3><ol><li><p>在底部的 status bar 添加 python 解释器，也可以使用 palette 来添加 interpreter。会自动检测到电脑上的 python interpreter (包括 anaconda 中创建的环境)</p></li><li><p>建立 debug 环境 craete a launch.json file，直接使用默认值就好，详细说明在 <a href="https://zhuanlan.zhihu.com/p/142642410">知乎链接</a></p><p>补充：默认配置只 debug 当前 folder 下的代码（“自己”的代码），如果是 pip/conda install 安装的代码（“别人”的代码），是不会进行 debug 的。如果想要 debug 所有代码则配置文件需要加上 <code>"justMyCode": false</code> <a href="https://blog.csdn.net/g534441921/article/details/102743393">CSDN 参考链接</a></p></li><li><p>Jupyter notebook 是插件里自带的功能，直接打开 ipynb 文件就可以运行代码块，通过选择 notebook 中的 kernel (具体一点说就是选择 conda 中的环境) 就能在你想要的环境中运行了，总体来讲还是比较方便</p></li></ol><h3 id="连接到远程服务器"><a href="#连接到远程服务器" class="headerlink" title="连接到远程服务器"></a>连接到远程服务器</h3><p>由于要跑一些模型，自己的电脑显卡根本跑不动，那就<del>白嫖</del>连接到实验室的服务器​</p><p>通过 vscode Extensions: <code>Remote-SSH</code> 完成，<a href="https://zhuanlan.zhihu.com/p/141205262">知乎教程</a></p><p>在 Remote Expolorer -&gt; SSH TARGETS -&gt; config 中添加配置</p><pre class="line-numbers language-config" data-language="config"><code class="language-config"># Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost random_name    HostName host_ip    User user_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>遇到了报错 <code>Resolver error: Error: Running the contributed command: '_workbench.downloadResource' failed.</code> 无法连接到服务器。原因可能在于服务器是在内网，没有办法在服务器上自动下载好 vscode-server，于是只能本地下载，然后上传</p><p>参考 <a href="https://blog.csdn.net/ibless/article/details/118610776">CSDN 链接</a> 解决问题</p>]]></content>
      
      
      <categories>
          
          <category> 软件基础 </category>
          
          <category> vs code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> vs code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CenterPoint 复现笔记</title>
      <link href="/archives/ba7995ee.html"/>
      <url>/archives/ba7995ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="CenterPoint-复现笔记"><a href="#CenterPoint-复现笔记" class="headerlink" title="CenterPoint 复现笔记"></a>CenterPoint 复现笔记</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ol><li><p>pytorch下载如果很慢，请采用镜像！</p></li><li><p>下载cmake使用apt，但要更新下载源为阿里云，这样版本才够新</p></li><li><p>安装spconv时报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">The following packages have unmet dependencies: gsettings-desktop-schemas <span class="token builtin class-name">:</span> Breaks: mutter <span class="token punctuation">(</span><span class="token operator">&lt;</span> <span class="token number">3.31</span>.4<span class="token punctuation">)</span> but <span class="token number">3.28</span>.4+git20200505-0ubuntu18.04.2 is to be installedE: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>网络上一个解决方案是使用aptitude</p><pre class="line-numbers language-SHell" data-language="SHell"><code class="language-SHell"># download aptitudesudo apt install aptitudesudo aptitude install &lt;packagename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>血泪教训，不要轻易使用aptitude，系统很多东西都被改写了，经过一番折腾升级到了ubuntu 20.04，也不知道之前安装的东西有没有被动</p><p>印象中提到”held packages”，应该按照那种方式解决</p></li><li><p>在下载 spconv 报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">CMake Error at CMakeLists.txt:2 <span class="token punctuation">(</span>project<span class="token punctuation">)</span>:  No CMAKE_CUDA_COMPILER could be found.  raise CalledProcessError<span class="token punctuation">(</span>retcode, cmd<span class="token punctuation">)</span>subprocess.CalledProcessError: Command <span class="token string">'['</span>cmake<span class="token string">', '</span>/home/declan/CenterPoint/spconv<span class="token string">', '</span>-DCMAKE_PREFIX_PATH<span class="token operator">=</span>/home/declan/anaconda3/envs/centerpoint/lib/python3.6/site-packages/torch<span class="token string">', '</span>-DPYBIND11_PYTHON_VERSION<span class="token operator">=</span><span class="token number">3.6</span><span class="token string">', '</span>-DSPCONV_BuildTests<span class="token operator">=</span>OFF<span class="token string">', '</span>-DCMAKE_CUDA_FLAGS<span class="token operator">=</span><span class="token string">"--expt-relaxed-constexpr"</span><span class="token string">', '</span>-DCMAKE_LIBRARY_OUTPUT_DIRECTORY<span class="token operator">=</span>/home/declan/CenterPoint/spconv/build/lib.linux-x86_64-3.6/spconv<span class="token string">', '</span>-DCMAKE_BUILD_TYPE<span class="token operator">=</span>Release<span class="token string">']'</span> returned non-zero <span class="token builtin class-name">exit</span> status <span class="token number">1</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尝试设置 CUDA 路径</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">export</span> <span class="token assign-left variable">PYTHONPATH</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${PYTHONPATH}</span>:/home/declan/CenterPoint"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/cuda-10.0/bin:<span class="token environment constant">$PATH</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">CUDA_PATH</span><span class="token operator">=</span>/usr/local/cuda-10.0<span class="token builtin class-name">export</span> <span class="token assign-left variable">CUDA_HOME</span><span class="token operator">=</span>/usr/local/cuda-10.0<span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/usr/local/cuda-10.0/lib64:<span class="token variable">$LD_LIBRARY_PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有效果。#241 issues和我问题一模一样 <a href="https://github.com/traveller59/spconv/issues/241">https://github.com/traveller59/spconv/issues/241</a></p><p>尝试增加路径 </p><p>try adding ‘-DCMAKE_CUDA_COMPILER=/usr/local/cuda-10.1/bin/nvcc’ in cmake_args</p><p>依旧失败</p><p>尝试使用不同版本的g++ sudo apt install g++-7，显示已经下载，我们需要切换版本</p><p>ls name* 可以列出所有name开头的包</p><p><a href="https://blog.csdn.net/FontThrone/article/details/104279224">https://blog.csdn.net/FontThrone/article/details/104279224</a></p><p>—slave 使得g++ gcc版本保持一致 70 90为重要权重priority</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 <span class="token number">70</span> --slave /usr/bin/g++ g++ /usr/bin/g++-7<span class="token function">sudo</span> update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 <span class="token number">90</span> --slave /usr/bin/g++ g++ /usr/bin/g++-9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对g++和gcc进行管理</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">  Selection    Path            Priority   Status------------------------------------------------------------* <span class="token number">0</span>            /usr/bin/gcc-9   <span class="token number">90</span>        auto mode  <span class="token number">1</span>            /usr/bin/gcc-7   <span class="token number">70</span>        manual mode  <span class="token number">2</span>            /usr/bin/gcc-9   <span class="token number">90</span>        manual mode<span class="token function">sudo</span> update-alternatives --config gcc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功</p></li><li><p>选择了 nuScenes mini 数据集</p></li><li><p>运行测试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python ./tools/dist_test.py infos_val_10sweeps_withvelo_filter_True.json  --work_dir work_dirs/CONFIG_NAME --checkpoint work_dirs/CONFIG_NAME/latest.pth --speed_test <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ModuleNotFoundError: No module named <span class="token string">'torchie'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>尝试将torchie文档直接加入到PYTHONPATH当中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">export</span> <span class="token assign-left variable">PYTHONPATH</span><span class="token operator">=</span><span class="token variable">$PYTHONPATH</span>:/home/delcan/CenterPoint/det3d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"./tools/dist_test.py"</span>, line <span class="token number">211</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span>  File <span class="token string">"./tools/dist_test.py"</span>, line <span class="token number">102</span>, <span class="token keyword">in</span> main    logger <span class="token operator">=</span> get_root_logger<span class="token punctuation">(</span>cfg.log_level<span class="token punctuation">)</span>  File <span class="token string">"/home/declan/CenterPoint/det3d/torchie/utils/config.py"</span>, line <span class="token number">146</span>, <span class="token keyword">in</span> __getattr__    <span class="token builtin class-name">return</span> getattr<span class="token punctuation">(</span>self._cfg_dict, name<span class="token punctuation">)</span>  File <span class="token string">"/home/declan/CenterPoint/det3d/torchie/utils/config.py"</span>, line <span class="token number">29</span>, <span class="token keyword">in</span> __getattr__    raise exAttributeError: <span class="token string">'ConfigDict'</span> object has no attribute <span class="token string">'log_level'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能是因为 nuscenes_mini 测试集原因</p><p><a href="https://github.com/tianweiy/CenterPoint/issues/106">https://github.com/tianweiy/CenterPoint/issues/106</a></p><p>我根据上面的内容对源码进行了修改，先尝试 train 一下</p><p>依旧报错，再检查可能是因为配置文件没有对的原因</p><p><a href="https://github.com/open-mmlab/mmdetection/issues/3093">https://github.com/open-mmlab/mmdetection/issues/3093</a></p><p>通过正确配置 <code>nusc_centerpoint_voxelnet_0075voxel_fix_bn_z.py</code> 文件解决上面报错</p><p><code>./configs/nusc/voxelnet/nusc_centerpoint_voxelnet_0075voxel_fix_bn_z.py</code></p><p>由于没有完整的 nuScenes 数据集，又有新的错误报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FileNotFoundError: <span class="token punctuation">[</span>Errno <span class="token number">2</span><span class="token punctuation">]</span> No such <span class="token function">file</span> or directory: <span class="token string">'nuScenes/samples/LIDAR_TOP/n008-2018-08-27-11-48-51-0400__LIDAR_TOP__1535385105950634.pcd.bin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>跳过这里，尝试跑一个 demo</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">python ./tools/dist_test.py ./configs/nusc/voxelnet/nusc_centerpoint_voxelnet_0075voxel_fix_bn_z.py --work_dir work_dirs/nusc_centerpoint_voxelnet_0075voxel_fix_bn_z --checkpoint work_dirs/nusc_centerpoint_voxelnet_0075voxel_fix_bn_z/latest.pth --speed_test <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FileNotFoundError: <span class="token punctuation">[</span>Errno <span class="token number">2</span><span class="token punctuation">]</span> No such <span class="token function">file</span> or directory: <span class="token string">'nuScenes/samples/LIDAR_TOP/n015-2018-10-02-10-50-40+0800__LIDAR_TOP__1538448754047572.pcd.bin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找目录发现这个文件其实是存在的，说明路径没有对，在 CentePoint 目录下添加 nuScenes 的软链接就可以解决了</p></li><li><p>最终 RuntimeError: CUDA out of memory 即使 batch_size = 1 也直接炸了，放弃！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> papers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CenterPoint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器部署hexo博客教程</title>
      <link href="/archives/d547a647.html"/>
      <url>/archives/d547a647.html</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云服务器ECS"><a href="#阿里云服务器ECS" class="headerlink" title="阿里云服务器ECS"></a>阿里云服务器ECS</h1><p>参考链接：</p><p><a href="https://www.bilibili.com/video/BV177411K7bH">狂神说_bilibili</a></p><p>官方链接：</p><p><a href="https://developer.aliyun.com/plan/grow-up">阿里云开发者成长计划</a></p><p><a href="https://developer.aliyun.com/adc/student?spm=a2c6h.19776329.J_4403085560.4.658b3d804yW1UU#J_3120529270">ECS训练营</a></p><p><a href="https://www.aliyun.com/product/ecs?spm=5176.224200.J_8058803260.52.1401586cYUB7hI">云服务器ECS</a></p><h2 id="学生机"><a href="#学生机" class="headerlink" title="学生机"></a>学生机</h2><p>如果是学生/新用户，一定要去看看有哪些优惠，比如<a href="https://developer.aliyun.com/plan/grow-up">阿里云开发者成长计划</a>。此刻阿里云提供的学生优惠是免费使用2个月的服务器资源。如果购买的话，一个1核2G的服务器就足够了</p><p><img src="/archives/d547a647/image-20210717163630430-1627213118656.png" style="zoom: 25%;"></p><h2 id="设置安全组"><a href="#设置安全组" class="headerlink" title="设置安全组"></a>设置安全组</h2><p>进入控制台开启端口，否则外部无法访问。除了默认的三个端口，通过“快速添加”，我再添加了 http(80) &amp; https(443) 两个端口。由于现在我对计算机网络一窍不通，所以先就这样吧</p><p><img src="/archives/d547a647/image-20210717155930905-1627213118658.png" style="zoom: 33%;"></p><h2 id="重置实例密码"><a href="#重置实例密码" class="headerlink" title="重置实例密码"></a>重置实例密码</h2><p>修改密码之后实例就会自动重启</p><p>然后就可以通过 <code>ssh root@ip</code> 连接到服务器，其中 ip 是你服务器的公网 ip</p><p><img src="/archives/d547a647/image-20210717162311907-1627213118658.png" style="zoom: 33%;"></p><h2 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy"></a>Enjoy</h2><p>之后就可以像操作 Linux 一样，操作自己的服务器啦！</p><h2 id="将博客部署到服务器上"><a href="#将博客部署到服务器上" class="headerlink" title="将博客部署到服务器上"></a>将博客部署到服务器上</h2><p>几个参考教程：<a href="https://developer.aliyun.com/article/775005">阿里云教程</a> <a href="https://blog.csdn.net/weixin_41154636/article/details/99685965">csdn 教程</a> <a href="https://cloud.tencent.com/developer/article/1632020">腾讯云教程</a> <a href="https://zhuanlan.zhihu.com/p/120743882">知乎教程</a></p><p>在开始之前，先根据之前的 Linux 安装教程简单设置一下自己的服务器：添加新用户，更改主机名</p><p>现在本地配置好 hexo 环境，具体配置过程在之前的博客有详细记录</p><h3 id="在服务器上安装-git"><a href="#在服务器上安装-git" class="headerlink" title="在服务器上安装 git"></a>在服务器上安装 git</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> yum <span class="token function">install</span> -y <span class="token function">git</span><span class="token comment"># 安装成功后查看 git version</span><span class="token function">git</span> --version <span class="token function">git</span> version <span class="token number">2.27</span>.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为之前在 Ubuntu 上使用的是 apt 包管理，在 CentOS 上则换为 yum 包管理。我试验了一下，如果不加 sudo 是不能下载成功的</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Error: This <span class="token builtin class-name">command</span> has to be run under the root user.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以我认为 yum 和 apt 一样需要 sudo 权限</p><h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><p>什么是 nginx？下面是官网描述</p><blockquote><p>NGINX is a high‑performance, highly scalable, highly available web server, reverse proxy server, and web accelerator (combining the features of an HTTP load balancer, content cache, and more).</p></blockquote><p>在我理解看来，部署网站的过程中 nginx 就是用来提供网页服务的服务器。这里就要更进一步理解什么是广义上的服务器</p><blockquote><p>从广义上讲，服务器是指网络中能对其它机器提供某些服务的计算机系统。从狭义上讲，服务器是专指某些高性能计算机，能通过网络，对外提供服务。</p></blockquote><p>使用以下命令安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> yum <span class="token function">install</span> -y nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="建立-git-仓库"><a href="#建立-git-仓库" class="headerlink" title="建立 git 仓库"></a>建立 git 仓库</h3><p>Hexo 可以使用 git 来部署，这样每次写完之后就都可以使用git来一键部署了，比较方便。我们先为系统添加一个 git 用户</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">useradd</span> -m <span class="token function">git</span> <span class="token comment"># 添加一个新用户</span><span class="token function">passwd</span> <span class="token function">git</span> <span class="token comment"># 设置git用户密码</span><span class="token function">su</span> <span class="token function">git</span> <span class="token comment"># 切换用户进行后续操作</span><span class="token builtin class-name">cd</span> /home/git/<span class="token function">mkdir</span> -p projects/blog <span class="token comment"># 把项目目录建立起来</span><span class="token function">mkdir</span> repos <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> repos<span class="token function">git</span> init --bare blog.git <span class="token comment"># 创建仓库</span><span class="token builtin class-name">cd</span> blog.git/hooks<span class="token function">vim</span> post-receive <span class="token comment"># 创建一个钩子</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>post-receive文件的内容如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/bin/sh</span><span class="token function">git</span> --work-tree<span class="token operator">=</span>/home/git/projects/blog --git-dir<span class="token operator">=</span>/home/git/repos/blog.git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>给 post-receive 添加执行权限</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chmod</span> +x post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>git init —bare 和 git init 有什么区别？ <a href="https://blog.csdn.net/sinat_34349564/article/details/52487860">csdn 链接</a></p><p>hooks有什么作用？ <a href="https://blog.csdn.net/weixin_41154636/article/details/99685965">csdn 链接</a></p><p>该钩子的意思是当本地有提交到服务器时，会将文件放在/home/hexo下</p><p><code>-f</code>这个参数如果在多人协作的博客中可能会引发不好的结果，因为他是强制更新的意思，会将本地版本覆盖掉远程服务器的版本，但是是个人的博客系统就无所谓了</p><h3 id="将公钥配置到服务器上"><a href="#将公钥配置到服务器上" class="headerlink" title="将公钥配置到服务器上"></a>将公钥配置到服务器上</h3><p>可以通过建立SSH信任关系，来免去登陆服务器时输入密码的步骤</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ssh-copy-id -i ~/.ssh/id_rsa.pub git@server_ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我尝试了一下自己手动复制 id_rsa.pub 到 authorized_keys 文件中，但是不能实现免密登陆，可能时复制时的字符串出现了问题，之前在 github 时也遇到了类似问题，直接复制公钥无法识别的情况</p><h3 id="更改-git-用户默认-shell"><a href="#更改-git-用户默认-shell" class="headerlink" title="更改 git 用户默认 shell"></a>更改 git 用户默认 shell</h3><p>为了安全，我们最好禁用 git 用户的 shell 登录权限。从而只能用 git clone，git push 等 git 操作访问服务器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cat</span> /etc/shells <span class="token comment"># 查看 git-shell 是否在登录方式里面</span><span class="token function">which</span> git-shell <span class="token comment"># 找到git-shell的路径，记下来</span><span class="token function">sudo</span> <span class="token function">vim</span> /etc/shells <span class="token comment"># 把 git-shell 路径添加到文件末尾</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后更改 git 用户 shell</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/passwd<span class="token comment"># 将原来的 /bin/bash 改为 /usr/bin/git-shell</span><span class="token comment"># git:x:1001:1001::/home/git:/usr/bin/git-shell</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 这样当你再次用 ssh 连接 git 用户时就会出现以下信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">fatal: Interactive <span class="token function">git</span> shell is not enabled.hint: ~/git-shell-commands should exist and have <span class="token builtin class-name">read</span> and execute access.Connection to your_ip closed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h3><p>我们修改<strong>本地</strong> hexo 配置文件 _config.yml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> git@your_ip<span class="token punctuation">:</span>/home/git/repos/blog.git<span class="token comment"># repo: git@github.com:name/name.github.io.git</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置好后就是 hexo 三连一键部署：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> /etc/nginx<span class="token function">cp</span> nginx.conf nginx_backup.conf <span class="token comment"># 备份配置文件</span><span class="token function">vim</span> nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有两个需要修改的地方：</p><ol><li><p>开头的 <code>user nginx</code> 要改为 <code>user root</code> </p></li><li><p>server 部分</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span><span class="token punctuation">{</span>        <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">80</span></span><span class="token punctuation">;</span> <span class="token comment">#监听80端口</span>        <span class="token directive"><span class="token keyword">server_name</span> 139.159.245.212</span><span class="token punctuation">;</span> <span class="token comment">#你的服务器名，通常是域名，如果是域名，你就需要监听80端口</span>        <span class="token directive"><span class="token keyword">root</span>       /home/git/projects/blog</span><span class="token punctuation">;</span> <span class="token comment">#网站的根目录</span>        <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>配置好后 <code>nginx -s reload</code> 重新加载配置信息，如果是第一次进行加载，则还需要先运行命令 <code>nginx -c /etc/nginx/nginx.conf</code></p><p>现在你就可以通过 ip 地址访问你的网页啦！</p><p>我发现由于我的网站封面太大(有6M)，打开时加载比较慢。所以我需要压缩一下封面图片的大小，推荐两个压缩图片网站</p><p><a href="https://compressjpeg.com/">https://compressjpeg.com/</a></p><p><a href="https://tinypng.com/">https://tinypng.com/</a></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>什么是域名？参考链接：<a href="https://www.bilibili.com/video/BV1kE411i7Jo?from=search&amp;seid=2556702162224412196">CodeSheep bilibili</a></p><p>建议阅读官方文档：<a href="https://help.aliyun.com/product/35473.html?spm=a2c4g.11186623.6.540.5b09689epNroGg">阿里云域名服务</a> <a href="https://help.aliyun.com/document_detail/61257.html?spm=a2c4g.11174283.2.6.36904c070bCdBM">什么是阿里云域名服务</a></p><p>根据官方文档 <a href="https://help.aliyun.com/document_detail/54068.htm?spm=a2c4g.11186623.2.13.5ff0689efHL52u#task-1830383">注册通用域名</a>，花费79元巨资注册了3年域名 hongkun.space</p><p><img src="/archives/d547a647/image-20210717235130445-1627213118658.png" style="zoom:50%;"></p><p>完成购买过后还需要进行：</p><ol><li><a href="https://help.aliyun.com/document_detail/35881.htm?spm=a2c4g.11186623.2.14.275a689e1pnnCW#concept-uhk-w5v-12b">实名认证</a>：一般3天左右审核通过</li><li><a href="https://beian.aliyun.com/pcContainer/formpage?page=selfBa&amp;pageAction=init&amp;orderType=100">域名备案</a>：初审1-2天，完整备案审核过程大概十多天</li></ol><p>注意需要先进行实名认证，然后才能完成备案</p><p>这里我还遇到一个问题，我通过学生优惠免费领取的服务器不能进行域名备案，因为至少需要有3个月的服务器使用权才能备案。看来还是得自己购买一个服务器，我再次花费巨资96元（新用户优惠）购买了一年的轻量应用服务器</p><h3 id="轻量应用服务器"><a href="#轻量应用服务器" class="headerlink" title="轻量应用服务器"></a>轻量应用服务器</h3><p><a href="https://www.aliyun.com/product/swas?spm=5176.8789780.J_8058803260.52.578945b5xsNx3V">轻量应用服务器</a>有单独的<a href="https://account.aliyun.com/login/login.htm?spm=5176.161059.J_5253785160.3.2c9ea505nvWZQs&amp;oauth_callback=https%3A%2F%2Fswas.console.aliyun.com%2F%3Fspm%3D5176.161059.J_835498.2.3e9f7fdaKmYuj7&amp;lang=zh#/servers">控制台</a>，用来部署网站性价比非常不错，配置过程和上面的云服务器一样</p><p>在轻量应用服务器的控制台中，域名解析和备案就在概览页面当中，根据流程进行即可</p><p><img src="/archives/d547a647/image-20210725173426850.png" style="zoom: 33%;"></p><h2 id="部署-SSL-证书-https"><a href="#部署-SSL-证书-https" class="headerlink" title="部署 SSL 证书 (https)"></a>部署 SSL 证书 (https)</h2><p>网站现在可以访问了，但是如下图可见，登陆网站会提示 <strong>Not Secure!!!</strong></p><p><img src="/archives/d547a647/image-20210802105224250.png" style="zoom: 50%;"></p><p>这可不能忍，于是我根据 <a href="https://blog.csdn.net/qq_33505555/article/details/106046616">CSDN 教程</a> 给阿里云服务器配置 SSL 证书，使用的是 FreeSSL 一个提供免费 https 证书申请的网站</p><h3 id="使用-FreeSSL-申请证书"><a href="#使用-FreeSSL-申请证书" class="headerlink" title="使用 FreeSSL 申请证书"></a>使用 FreeSSL 申请证书</h3><p>老规矩，先看看 <a href="https://blog.freessl.cn/tag/ssl-apply/">官网教程</a></p><ol><li><p>生成 CSR <a href="https://cloud.tencent.com/document/product/400/5367">什么是 CSR ? 腾讯云文档</a></p><p>教程中推荐使用 Keymanager 生成</p></li><li><p>在阿里云服务器中配置 DNS 解析，并对配置进行检测和验证</p><p>验证成功后可以在 FreeSSL 控制台中查看证书</p><p><img src="/archives/d547a647/image-20210802141326078.png" style="zoom:33%;"></p><p>在“更多操作”中可以下载证书，一个 pem 文件，一个 private.key</p><p><img src="/archives/d547a647/image-20210802141919162.png" style="zoom:33%;"></p></li><li><p>然后将证书 .pem 文件导入到 keymanager 中</p><p><img src="/archives/d547a647/image-20210802170924734.png" style="zoom: 25%;"></p></li><li><p>进行一键部署。基于你自己的框架，选择不同的部署方法，我选择部署到 Nginx 上。这里的“一键部署”实质上就是上传你的证书到服务器上</p><p><img src="/archives/d547a647/image-20210802171457165.png" style="zoom: 33%;"></p><p>部署成功过后，使用 <a href="https://myssl.com/">myssl.com </a> 检查网站的安全性。但是如果你的 Nginx 配置不对的话，</p></li><li><p>配置 Nginx</p><p>现在我们希望通过 https 443 端口来打开网站，与之前监听 http 80 端口，我们监听 443 端口，然后将 80 端口重定向</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>      <span class="token comment">#listen 80;</span>      <span class="token directive"><span class="token keyword">listen</span> <span class="token number">443</span></span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">ssl</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">ssl_certificate</span> /etc/ssl/cert.pem</span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">ssl_certificate_key</span> /etc/ssl/key.pem</span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">server_name</span>  hongkun.space</span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">root</span>         /home/git/blog</span><span class="token punctuation">;</span>  ...  <span class="token punctuation">}</span>  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>      <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>      <span class="token directive"><span class="token keyword">server_name</span> hongkun.space      <span class="token comment"># permenant redirect to https</span>      return <span class="token number">301</span> https://hongkun.space<span class="token variable">$request_uri</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置好过后重启 <code>nginx -s reload</code></p></li><li><p>现在访问网站，旁边就有高贵的<span class="github-emoji"><span>🔒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f512.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="/archives/d547a647/image-20210802173016910.png" style="zoom:50%;"></p><p>部署成功过后，还可以使用 <a href="https://myssl.com/">myssl.com </a> 检查网站的安全性</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件基础 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs231n assignment2 笔记</title>
      <link href="/archives/407bb789.html"/>
      <url>/archives/407bb789.html</url>
      
        <content type="html"><![CDATA[<h1 id="cs231n-2021-Assignment-2-note"><a href="#cs231n-2021-Assignment-2-note" class="headerlink" title="cs231n 2021 Assignment 2 note"></a>cs231n 2021 Assignment 2 note</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>assignment 模板: <a href="https://github.com/cs231n/cs231n.github.io">github</a> </p><p>官方: <a href="https://cs231n.github.io/assignments2021/assignment2/">课程链接</a></p><p>assignment 参考链接: <a href="https://github.com/amanchadha/stanford-cs231n-assignments-2020">2020</a></p><p>发现了一种新的模式: pycharm + git + anaconda &amp; jupyter</p><p>上面的组合能够帮助写代码的效率提升，pycharm 能够帮助调试，git 用于版本管理，conda 用于环境管理。jupyter 在测试代码块上有很大的优势，并且很多 cs231n 的作业形式都是以 ipynb 的文件类型发布，更适合在 jupyter 上打开，而且 jupyter 能够直接使用创建好的 conda 环境，特别方便</p><p>经过一番折腾，最终决定使用 vs code 替换 pycharm，原因是 vs code 有 jupyter notebook 插件，可以直接显示在 editor 内，比 Pycharm 更方便而且以后想要学习其他语言 vs code 优势更大</p><h2 id="过程中的编程复习"><a href="#过程中的编程复习" class="headerlink" title="过程中的编程复习"></a>过程中的编程复习</h2><ol><li><p>重新复习了 numpy 的一些用法，一个重要思想就是尽量少考虑使用循环解决，要以 index 索引思想来解决数据的操作问题。</p><p>reshape已经存在的shape</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>b<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当接受参数是元组而是可变参数 <em>args 的时候，可以用 </em>tuple 来将参数变为 *args</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要学会善用矩阵点乘 A * B，是将对应元素相乘，在计算模的时候，或者当其中一个是 indication function 时很有用</p></li><li><p>重新复习了字典的用法，核心是创造字典，dict(), dict.fromkeys()</p><p>字典的 key, val 迭代器，如果不用 items，则只有 key</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token keyword">in</span> <span class="token builtin">dict</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>pas<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>对于格式化字符串有新的认知，下面例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>self<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'b%d'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> weight_scale <span class="token operator">*</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以用这样的形式来调用 key</p></li></ol><h2 id="Fully-Connected-Networks"><a href="#Fully-Connected-Networks" class="headerlink" title="Fully Connected Networks"></a>Fully Connected Networks</h2><ol><li>对于网络的认知有了更新。要把层(layer, w)和点(node, x)分开来看，这样网络结构才更清晰。一般隐藏层不包含输出层</li><li><strong>反向传播熟悉 back propagation，尤其是矩阵相乘的反向传播，只需要记住结论就行了。对于广播过后的结果，需要将广播的矩阵作 sum 处理，得到广播前的对应元素梯度</strong></li><li>5 layers 和 3 layers 网络优化时比较，差异在哪里？5 layer 更难优化，对于初始值敏感</li><li><strong>对于优化算法进行了进一步了解，由三个核心点：AdaGrad, Momentum, EWA 最后自然推出 Adam 优化算法</strong></li><li><strong>在编写代码的时候重要的版本需要保存，这就需要使用 git</strong></li></ol><h2 id="Batch-normalization"><a href="#Batch-normalization" class="headerlink" title="Batch normalization"></a>Batch normalization</h2><p>进一步清晰了 bn 的过程与作用，可以回看自己的笔记了解详情</p><h3 id="Inline-Question-1"><a href="#Inline-Question-1" class="headerlink" title="Inline Question 1"></a>Inline Question 1</h3><p><strong>How does the scale of weight initialization affect models with/without batch normalization differently, and why?</strong></p><p>You should find that using batch normalization helps the network to converge much faster. </p><p>使用 batch normalization 会让网络在训练集上收敛更快。这和普通的 normalization 是一个道理，减少 zigzag 拐弯</p><p>还有几个需要知道和理解的点是：</p><ol><li>batch normalization 帮助缓解梯度消失/爆炸的问题，这将减缓因为 weight initialization 过大或过小而产生梯度消失/爆炸的问题</li><li>batch normalization 有一定的正则化效果，避免过拟合</li></ol><p><img src="/archives/407bb789/image-20210707160726541.png" style="zoom: 67%;"></p><h3 id="Inline-Question-2"><a href="#Inline-Question-2" class="headerlink" title="Inline Question 2"></a>Inline Question 2</h3><p><strong>hat does this imply about the relationship between batch normalization and batch size? Why is this relationship observed?</strong></p><p>一般规律是：batch size 越大训练集上收敛越快。当 batch size 比较小的时候，比 baseline 速度更慢，原因在于过少的样本带来的偏差太大，这样的噪音会影响训练和测试表现</p><p><img src="/archives/407bb789/image-20210707164225500.png" style="zoom: 67%;"></p><p>在训练和测试时均会用到 bn layer，测试时用的 $\mu,\sigma$  参数是训练过程中的指数加权平均 EWA</p><h3 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h3><p>用在 RNN 中更多，如果以后接触 NLP 领域的话再深入整理。简单的解释 <a href="https://zhuanlan.zhihu.com/p/74516930">知乎链接</a> </p><p>假设我们有 10行 3列 的数据，即我们的batchsize = 10，每一行数据有三个特征，这是一种“列缩放”。</p><p>而layer方向相反，它针对的是每一行进行缩放。即只看一笔数据，算出这笔所有特征的均值与方差再缩放。这是一种“行缩放”。</p><p>Q: 为什么 gamma 和 beta 还是原来的 (D, ) 形状？Layer normalization 在 RNN 中有什么作用？</p><p><img src="/archives/407bb789/image-20210707200112133.png" style="zoom: 67%;"></p><p>看得出 layer normalization 在训练上也是有一定作用的，但在图像方面相比于 batch normalization 效果差一点，另一个比较自然的结果是，对于 layer normalization 来说 hidden dimension 取较大值较好</p><h2 id="Drop-out"><a href="#Drop-out" class="headerlink" title="Drop out"></a>Drop out</h2><p>两行代码解决 (inverted) dropout layer 核心</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mask <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">input</span><span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">&lt;</span> poutput <span class="token operator">=</span> <span class="token builtin">input</span> <span class="token operator">*</span> mask <span class="token operator">/</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>vallina dropout 是在 test 时将输出乘以 p 使得输出是一个合理期望值。但如果我们在训练的时候已经除以 p 了，在测试时就不需要作任何操作。下图为正则化效果 regularization</p><p><img src="/archives/407bb789/image-20210708160433242.png" style="zoom:67%;"></p><h2 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h2><ol><li><p>用嵌套循环实现了最原始的卷积操作，使用 np.pad 函数能实现 padding 操作，感觉这个函数的参数不是那么灵活</p></li><li><p>返回最大值坐标 np.argmax，如果想要返回多元坐标还需要使用 np.unravel_index 转化</p><p><code>np.unravel(indices, shape)</code></p></li><li><p>assignment 提供了 fast_layers.py 来实现快速卷积操作，比我自己写的循环代码要快 1000 多倍，使用了 im2col 技巧以及 Cpython extension</p></li><li><p>为什么在正则化的时候正则项中不包括偏差 b? 个人理解认为 b 对于正则化的贡献并不大，而 w 参数则占据了绝大部分的参数。</p></li></ol><h3 id="Spatial-Batch-Normalization"><a href="#Spatial-Batch-Normalization" class="headerlink" title="Spatial Batch Normalization"></a>Spatial Batch Normalization</h3><p>这是卷积神经网络特有的 batch normalization。之前使用的 batch normalization 面对的是 (N, D) 形状的数据，但卷积过后得到的输出是类似 (N, C, H, W) 这样的多维数据。那我们应该怎样去计算这一批数据的统计量 $\mu, \sigma$ 呢？</p><p>如果沿着之前的思维，我们只沿着样本数据轴 N 去计算 $\mu, \sigma$ </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># data.shape = (N, C, H, W)</span>mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>var  <span class="token operator">=</span> np<span class="token punctuation">.</span>var<span class="token punctuation">(</span>data<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这将会得到 (C, H, W) 形状的统计量，其中每一个值 (c, h, w)，其样本来自于 N 个像素点（同一 channel，同一位置）。但我们希望样本的数量更广泛一些，具体一点来说，我们希望样本来自于 N 个 feature map (H, W)，用 numpy 表示为</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># data.shape = (N, C, H, W)</span>mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>var <span class="token operator">=</span> np<span class="token punctuation">.</span>var<span class="token punctuation">(</span>data<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这将会得到 (C,) 形状的统计量，即：得到了对于某一个 channel 的统计量，这是合理的，因为同一个 channel 我们使用的是同一个 kernel。这样我们不仅得到了更广泛样本的统计量，还减少了参数数量</p><p>如果要使用之前写的 batch_norm 函数的话可以将数据转化为 (N <em> H </em> W, C) ，在 numpy 中使用 transpose + reshape 就可以完成</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> C<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Spatial-Group-Normalization"><a href="#Spatial-Group-Normalization" class="headerlink" title="Spatial Group Normalization"></a>Spatial Group Normalization</h3><p>一张图展示Batch Norm， Layer Norm ，Group Norm的区别</p><p><img src="/archives/407bb789/image-20210710193505933.png" alt="image-20210710193505933"></p><p>Group Norm可以理解为在layer Norm的基础上，输入维度为 (N, C, H, W)，对C进行分组，即 (N, G, C//G, H, W)。为了完成这一部分，重新思考了如何基于系统计算 back propagation</p><p><strong>可以以重要的中间变量为节点，根据计算图逐步推导梯度。难点在于有矩阵参与的计算，经常伴随着矩阵形状的改变，在进行 back propagation 中一定要让梯度跟着这些计算进行升维和降维，可以想象为梯度会随着这些节点形状的变化进行复杂的流动，有分流(例如降维度)，也有汇合(例如 broadcast)</strong></p><p>例如，在 forward pass 中 broadcast 会将矩阵升维，sum 会将矩阵降维，如果在 backward pass 中遇到 broadcast 操作时，则需要将 upper_grad 根据对应维度求和，举个例子，如果我们要求下面 X 的梯度的话，代码应该时这样的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># input: X, X.shape = (N, D)</span><span class="token comment"># f(X) = X - np.mean(X)</span><span class="token comment"># upper_grad = dout, dout.shape = (N, D)</span>dmean <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dout<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># sum broadcast dimension</span>dmean <span class="token operator">=</span> dmean <span class="token operator">/</span> N<span class="token comment"># mean operation back prop</span>dX <span class="token operator">=</span> dout <span class="token operator">-</span> dmean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想不使用计算图直接按照一般的矩阵梯度计算，遇到对矩阵/向量求导时，就会出现张量，也就是说维度会增加，需要熟悉张量的运算及其思维。还是借用上面的例子，但我们把平均值作为 (N, D) 形状来看待</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># input: X, X.shape = (N, D)</span><span class="token comment"># f(X) = X - np.mean(X) * np.ones(X.shape)</span><span class="token comment"># upper_grad = dout, dout.shape = (N, D)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\frac{\partial{loss}}{\partial{f(x)}} = dout，\ f(x)=x-\mu\\\frac{\partial{f(x)}}{\partial{\mu}} = a\ ((N\times D) \times (N\times D))\ shape\ tensor\\\frac{\partial{loss}}{\partial{\mu}}=\frac{\partial{loss}}{\partial{f(x)}} ·\frac{\partial{f(x)}}{\partial{\mu}}=dout\\\frac{\partial{\mu}}{\partial{x}} = a\ ((N\times D) \times (N\times D))\ shape\ tensor\\\frac{\partial{loss}}{\partial{x}}=\frac{\partial{loss}}{\partial{f(x)}}·\frac{\partial{f(x)}}{\partial{x}} - \frac{\partial{loss}}{\partial{f(x)}}·\frac{\partial{f(x)}}{\partial{\mu}}·\frac{\partial{\mu}}{\partial{x}}=dout -dout·\frac{\partial{\mu}}{\partial{x}}</script><p>这将是一种普适的方法，更加抽象化，能够处理任何的矩阵求导，但不推荐实际中使用。</p><p>不论使用哪种方法，最核心的还是要理解梯度流动的本质——某一个变量的变动能够引起输出多少变动</p><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h3 id="Fully-Connected-Layer"><a href="#Fully-Connected-Layer" class="headerlink" title="Fully Connected Layer"></a>Fully Connected Layer</h3><p>现在卡在了 solver 上</p><p>不能得到 overfitting 的结果</p><ol><li><p>尝试更换 solver 看能否得到不一样的结果</p><p>失败了</p></li><li><p>尝试使用2016的所有答案，看是否是自己的代码出问题了</p><p>失败了</p><p>小技巧 Ctrl+r 能够更换 pycharm 相同字段</p></li><li><p>尝试更改 colab 本身的文件，使用2016年的colab文件</p><p>成功，原因在于 learning rate 太小了，不能找到全局最优</p></li></ol><h3 id="Batch-normalization-1"><a href="#Batch-normalization-1" class="headerlink" title="Batch normalization"></a>Batch normalization</h3><ol><li><p>卡在了计算 back prop 上</p><p>最后出现的失误还是在于每一个公式必须要精确才行</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">norm_x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> sample_mean<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>sample_var <span class="token operator">+</span> eps<span class="token punctuation">)</span>norm_x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> sample_mean<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>sample_var<span class="token punctuation">)</span> <span class="token operator">+</span> eps<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面两个式子虽然在计算结果上相差不多，但是在网络的计算中，一点点的误差传播过后会变得越来越大</p></li><li><p>尝试使用 jupyter 进行编程，遇到问题：The kernel appears to have died. It will restart automatically</p><p>以为是 jupyter 的问题，但测试了不同的软件都出错了，最终发现是自己代码的问题！当找了一圈没有找到答案时，可能就要怀疑自己了，而不是怀疑软件出了问题！不过这也有好处，让我决定放弃使用 pycharm 转战 vs code</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
          <category> cs231n </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs231n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装笔记</title>
      <link href="/archives/53e3a160.html"/>
      <url>/archives/53e3a160.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Linux笔记"><a href="#安装Linux笔记" class="headerlink" title="安装Linux笔记"></a>安装Linux笔记</h1><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><ol><li><p>如何安装双系统：移步 bilibili（建议安装最新版，美观且体验更友好）</p></li><li><p>设置root密码。然后创建新用户，并设置新用户密码以及 sudo 权限。</p></li><li><p>修改 /etc/hostname，reboot 后永久更改主机名</p></li><li><p>可能出现启动windows的时候有bitlocker，禁用bitlocker安全协议</p></li><li><p>配置代理clash，从youtube上视频学的（迷途小书童），要点就是将已经配置好的config.yml和Country.mmdb文件移动到./.config/clash文件夹下面，重新命名 config.yml 为 config.yaml，通过 clash dashboard 切换节点 <a href="http://clash.razord.top/">http://clash.razord.top/</a></p><p>让Terminal走代理的方法(desktop上的settings中设定会改写terminal端，使用export改写则不会影响desktop)，参考 <a href="https://zhuanlan.zhihu.com/p/46973701">知乎链接</a></p></li><li><p>官网下载git anaconda chrome typora chrome baiduyun vscode软件并安装</p><p>conda install, pip install 下载速度慢时，请使用国内镜像源，例如：</p><ol><li><p><a href="https://mirrors.bfsu.edu.cn/help/anaconda/">北京外国语大学镜像源</a>（推荐，截至2021/6/15下载速度很快）</p></li><li><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">清华镜像源</a></p></li></ol></li><li><p>配置nvidia driver: 根据 <a href="https://zhuanlan.zhihu.com/p/59618999">知乎链接</a> ，在命令行里下载推荐的driver。如果在配置nvidia driver的过程中出现连接不上显卡，可能需要关闭 security boot。根据 <a href="https://zhuanlan.zhihu.com/p/108930996">知乎链接</a> 下载安装CUDA，选择runfile。</p><p>参考 <a href="https://zhuanlan.zhihu.com/p/336429888">稚晖君</a> 的教程，如果想移除所有cuda, cudnn, nvidia driver</p><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">sudo apt-get remove --purge nvidia*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>教程里还教了如何更新apt source为阿里云镜像，里面的软件会更新而且下载更快。同时也设置了 sudo，让每一次 sudo 都不需要输入密码</p></li><li><p>pip install 遇到问题 enter your password to unlock your login keyring</p><p>解决方法，直接cancel，或者在passwd and key中更改密码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件基础 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 教程</title>
      <link href="/archives/2121b11b.html"/>
      <url>/archives/2121b11b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-reorganiszed-note"><a href="#Git-reorganiszed-note" class="headerlink" title="Git reorganiszed note"></a>Git reorganiszed note</h1><p>重新整理了 git 的常用操作命令，能够覆盖大部分版本管理场景，适合作为提纲进行复习</p><p>整理来自：<a href="https://www.bilibili.com/video/BV1FE411P7B3?from=search&amp;seid=1905221215711628694">bilibili</a> <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当遇到国外资源下载很慢的时候，可以考虑使用镜像资源</p><p>视频里使用了淘宝镜像安装 windows 版本 <a href="https://npm.taobao.org/mirrors/">https://npm.taobao.org/mirrors/</a></p><p>ubuntu 直接使用 apt install git 使用阿里云镜像</p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>首先要理解的是，在windows 中 git bash 的基本操作命令和 Linux  terminal 是一样的。在 Linux 中 git 是集成到 terminal 当中的</p><h3 id="git-config"><a href="#git-config" class="headerlink" title="git  config"></a>git  config</h3><p>配置用户名和邮箱</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global user.name <span class="token string">'your_name'</span><span class="token function">git</span> config --global user.email <span class="token string">'***@qq.com'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后的所有提交都会使用你的用户和邮箱</p><p>还可以根据需求配置代理</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 设置代理</span><span class="token function">git</span> config --global http.proxy http://127.0.0.1:1080<span class="token comment"># 查看代理</span><span class="token function">git</span> config --global --get http.proxy<span class="token comment"># 取消代理</span><span class="token function">git</span> config --global --unset http.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Git-基本理论"><a href="#Git-基本理论" class="headerlink" title="Git 基本理论"></a>Git 基本理论</h2><p>直接上图，重点关注左侧命令</p><p><img src="/archives/2121b11b/image-20210628141830141.png" style="zoom:80%;"></p><p>从工作区 -&gt; 暂存区：git add</p><p>从暂存区 -&gt; 本地仓库：git commit</p><p>从本地仓库 -&gt; 远程仓库：git push</p><p>这三个命令就能够让你感受到 git 版本控制的基本流程</p><h2 id="Git-仓库搭建"><a href="#Git-仓库搭建" class="headerlink" title="Git 仓库搭建"></a>Git 仓库搭建</h2><h3 id="git-init-amp-git-clone"><a href="#git-init-amp-git-clone" class="headerlink" title="git init &amp; git clone"></a>git init &amp; git clone</h3><p>生成仓库(master 分支)的两种方法</p><ol><li><p>git init 初始化，生成 .git 文件</p></li><li><p>git clone url 克隆远程仓库</p></li></ol><p>删除仓库则只需要删除 .git 文件夹即可</p><h2 id="Git-文件基本操作"><a href="#Git-文件基本操作" class="headerlink" title="Git 文件基本操作"></a>Git 文件基本操作</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>git status 查看 git 文件状态，git status file_name 可指定文件</p><p>文件的几种状态：</p><ol><li>untracked 文件在文件夹中，从没有 add 过</li><li>unmodify 文件已经 commit 且库中最新版本和当前文件是一致的，可以通过 git rm 将其移出版本库管理</li><li>modified 文件在 commit 或者 add 过后有过修改，可以使用 git checkout 丢弃修改</li><li>staged (文件在之前 commit 过后有过修改) 经过 add，没有 commit</li></ol><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>有些时候我们不想把某些文件纳入版本控制中，可在主目录下建立 .gitignore 文件，例如你不详把 txt 类型文件进行版本控制，则在 .gitignore 文件中写入 *.txt 即可，其他具体规则不作介绍，也比较简单。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add file_name 将文件加入暂存区，文件成为 staged 状态</p><p>git add . 将当前文件夹 add，比较方便快捷</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit -m ‘massage you want to say’ 将暂存区所有文件加入到版本库中，并留下此次提交的 message</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>将已经 commit 的文件从版本库中移除变为 untracked 文件</p><p>git rm —cached file_name</p><h2 id="Git-版本回退"><a href="#Git-版本回退" class="headerlink" title="Git 版本回退"></a>Git 版本回退</h2><h3 id="git-log-amp-git-reflog"><a href="#git-log-amp-git-reflog" class="headerlink" title="git log &amp; git reflog"></a>git log &amp; git reflog</h3><p>git log 查看 commit 历史记录，id，作者等信息</p><p>git reflog 查看所有的操作</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>回退到某一个 commit 版本，id 只用写前几位，git 自动识别</p><p>git reset —hard commit_id</p><p>回退到上一个 commit 版本，如果回退两个则是 HEAD^^</p><p>git reset —hard HEAD^</p><p>—hard 参数其实代表回退到某个 commit 后，该 commit 之后的记录都会被丢弃。但 git 永远都有后悔药吃，如果回退到以前的版本想要再回来，使用 git reflog 查看所有命令</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>git checkout 能够让文件回到最近一次 add 或者 commit 时的状态</p><p>git checkout file_name</p><h2 id="分支与冲突"><a href="#分支与冲突" class="headerlink" title="分支与冲突"></a>分支与冲突</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>从这里我们可以更加深入理解 git 的工作形象，working tree</p><p>除了 master 分支，我们还可以创建其他分支，HEAD 所指的就是 working tree “生长”的地方，然后我们将分支合并，也即让 master “赶上来”，再删除 dev 分支。git 分支还有一个一般规则是，master 分支永远是最稳定的分支，开发都在 dev 或其他分支上进行</p><p><img src="/archives/2121b11b/branch_1.png" style="zoom: 50%;"></p><p><img src="/archives/2121b11b/branch_2.png" style="zoom: 50%;"></p><p><img src="/archives/2121b11b/branch_3.png" style="zoom:50%;"></p><p>使用 git branch 查看分支情况，也可用于删除分支</p><p>git branch -d branch_name</p><h3 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h3><p>使用 git swich 来创建和切换分支</p><p>git switch -c branch_name</p><p># 复制远程的分支到本地</p><p>git switch -c branch_name origin/branch_name</p><p>git switch branch_name</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>将某个分支合并到当前分支</p><p>git merge branch_name</p><p>如果发生了冲突：两个 branch 中在同一个文件中有不同的修改而无法合并，那么需要解决冲突。（判断文件是否有修改，是根据 commit id 之类的标记节点来判断的，但是否存在冲突则是根据文件的内容）</p><p><img src="/archives/2121b11b/branch_4.png" style="zoom:50%;"></p><p>先使用 git status 查看哪个文件发生冲突，然后使用 vim 编辑，git 会自动在文档中标明冲突的地方。怎样修改无所谓，只要你 add &amp; commit 过后，git 就会默认冲突解决，并将你的文件作为最新的版本加入版本库中，更新 working tree</p><p>如果对于 git 中 recursive 3-way merge 算法感兴趣，可以参看<a href="https://en.wikipedia.org/wiki/Merge_(version_control">维基百科</a></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程仓库-github-or-gitee"><a href="#添加远程仓库-github-or-gitee" class="headerlink" title="添加远程仓库 github or gitee"></a>添加远程仓库 github or gitee</h3><p>gitee 为国内网站，传输速度更快。通过以下步骤将本机与远程连接（以 github 为例）：</p><ol><li><p>注册 github 账号</p></li><li><p>生成 ssh 公钥</p><ol><li><p>在本机 user 目录下找到 ssh 文件夹（安装 git 过后这个文件夹会自动生成）</p></li><li><p>在 shell 中运行以下命令生成 ssh 密钥，其中 rsa 是一种加密算法 </p><p><code>ssh-keygen -t rsa</code></p><p>之后你就能在 .ssh 文件中找到 id_rsa 和 id_rsa.pub 文件</p></li></ol></li><li><p>添加 id_rsa.pub 到 github 账户设置中</p></li></ol><p>这样就把本机和远程仓库连接起来了，具体的说是将本机与你的 github 账号通过 ssh 连接起来了</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>你的账号里可以有很多的仓库，我们想要将本地仓库与某一个指定仓库链接使用以下命令即可</p><p>git remote add origin [url]</p><p>远程仓库的名字叫 origin，这是 git 的默认叫法，url 是仓库的 https 或者 ssh</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>把本地库的内容推送到远程仓库，使用下面命令</p><p>git push -u orgin master</p><p>这样就把本地 master 分支内容推送到了远程新的 master 分支。-u 参数为 set upstream 的意思，在推送的同时将我们的本地 master 分支和远程 master 分支联系起来（相当于作了 <code>git branch -u origin</code> ），今后则可以直接输入 git push 来简化推送命令，强烈建议在第一次 push 的时候带上 -u 参数</p><p>其他本地分支与远程分支的 push 和连接也是一样的，把上面命令的 master 改为对应分支的名字（例如：dev 分支）即可，前提是本地要切换到那个分支，且远程存在同名的分支。</p><p>个人认为 git push 一般是在同名的本地分支和远程分支之间进行</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>文件冲突不仅出现在本地的 merge 当中，也存在在 push 操作当中。push 的本质也是将本地和远程这两个 branch 进行融合。当这个远程仓库只有你一个人在 push 时，是不会有冲突的，因为远程的 working tree 只会一直往前延伸；当有多个人都在对某一个文件进行修改，working tree 就相当于有了多个分支，在 push 的时候就会形成冲突。如果有远端的冲突形成，就需要使用 git pull</p><p>git pull 有两个作用，一个是拉取代码到本地，另一个是尝试与本地代码合并，如果不能使用 fast forward 合并，则需要自己来修改冲突部分，这部分和 git merge 是一样的</p><h2 id="Git-IDE"><a href="#Git-IDE" class="headerlink" title="Git + IDE"></a>Git + IDE</h2><p>现在 git 和很多 IDE 都有联动，可以直接在 IDE 中方便的操作 git！</p><p>以 pycharm 为例，只需要在你的项目文件夹下 git init 就可以 </p>]]></content>
      
      
      <categories>
          
          <category> 软件基础 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery 教程</title>
      <link href="/archives/b129f5ae.html"/>
      <url>/archives/b129f5ae.html</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-matery-note"><a href="#hexo-theme-matery-note" class="headerlink" title="hexo-theme-matery note"></a>hexo-theme-matery note</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>参考原 github 项目进行整理：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p><h3 id="config-yml-的修改建议"><a href="#config-yml-的修改建议" class="headerlink" title="_config.yml 的修改建议"></a>_config.yml 的修改建议</h3><p>在 hexo 根目录下的 _config.yml 文件中：</p><ol><li><p>切换 theme 为 hexo-theme-matery</p></li><li><p>url 改为网站 url (如：<a href="http://xxx.github.io">http://xxx.github.io</a>)</p></li><li><p>per_page 数值改为6及6的倍数，这样文章列表在各个屏幕下都能较好显示</p></li><li><p>插入图片（有点复杂，可以先跳过）。根据 <a href="https://zhuanlan.zhihu.com/p/265077468">知乎链接</a> 配置好 post_asset_folder，里面提到的 typora 技巧也很实用，建议采用。且一般来讲链接中提到的 hexo-renderer-marked 插件都是已经内置好的，不然你的博客不会渲染成功。</p><p>但是这个方法不能控制图片大小，而且配置过 typora 后还要再改图片的路径。我再下载了 hexo-asset-image 插件过后，直接用 typora 中的 html 方法 <code>&lt;img src='post_name/img.jpg'&gt;</code>引用图片，不需要二次更改路径</p></li></ol><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> hexo new page <span class="token string">'categories'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>categories 页是用来展示所有分类的页面</p><p>修改 <code>/source/categories/index.md</code> 文件的 front-matter (Front-matter 是文件最上方以 —- 分隔的区域，用于指定个别文件的变量)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">---title: categoriesdate: <span class="token number">2018</span>-09-30 <span class="token number">17</span>:25:30type: <span class="token string">"categories"</span>layout: <span class="token string">"categories"</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 page 和 post 的区别：两者其实很相似，你可以把 page 看作是特殊的 post，用来放置一些特殊内容：如分类、标签等等。</p><p>hexo 的分类是有等级关系的，我们以下面的 post front-matter 为例</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">title: 我的博客搭建笔记date: 2021-06-29 15:26:41tags:<span class="token list punctuation">-</span> hexo<span class="token list punctuation">-</span> 博客搭建categories:<span class="token list punctuation">-</span> 软件基础<span class="token list punctuation">-</span> hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个文件在分类时会被分配到所有提到的 categories 中，这些 categories 的路径是逐渐往下的 <code>/categories/软件基础/hexo/</code>，它们都有自己的 page 来收纳属于自己类别的文章。</p><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p>新建 page</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改对应 index.md</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">---title: tagsdate: <span class="token number">2018</span>-09-30 <span class="token number">18</span>:23:38type: <span class="token string">"tags"</span>layout: <span class="token string">"tags"</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给 post 指定 tags 只需要在 front-matter 中写好就行了，如上面 categories 的例子。</p><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><h3 id="新建留言板-contact-页"><a href="#新建留言板-contact-页" class="headerlink" title="新建留言板 contact 页"></a>新建留言板 contact 页</h3><h3 id="新建友情链接-friends-页"><a href="#新建友情链接-friends-页" class="headerlink" title="新建友情链接 friends 页"></a>新建友情链接 friends 页</h3><p>新建方法都是和上面的方法一样的</p><h2 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h2><h3 id="名称、路径、图标"><a href="#名称、路径、图标" class="headerlink" title="名称、路径、图标"></a>名称、路径、图标</h3><p>配置菜单导航的名称、路径url、和图标icon，配置文件在 <code>themes/hexo-theme-matery/._config.yml</code></p><p>更改 menu 部分即可</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">menu:  <span class="token comment"># 把 Index 改为 Home</span>  Home:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可该的部分：</p><ol><li>名称可以是中文</li><li>图标可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</li><li>还可以使用二级菜单。二级菜单在实现上可以理解为创建了一个软链接，到你指定的 page 上。</li></ol><p>由于我对于这个导航还是比较满意，就不作过多修改</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><p>由于代码看不明白，找到了一个比较详细的教程</p><p><a href="https://sunhwee.com/posts/6e8839eb.html">https://sunhwee.com/posts/6e8839eb.html</a></p><p>根据上面的链接修改了版权信息，增加了网站运行时间，访问人数的代码目前不需要修改</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code></p><p>以上的设置并不管用，没有高亮也没有行号</p><p>但是我下载了 hexo-prism-plugin 又卸载掉这个插件，就有高亮了，但依旧没有行号</p><p>考虑是 matery.css 文件中 pre 下 paddidng 不够大的问题，增加 padding 但依然没能解决</p><p>考虑是不是本身 prism 文件出了问题，重新到官网上下载了 prism.js 和 prism.css 替换原来系统中对应的文件，同时调整上面提到的 padding 参数，最后成功！</p><p>prism.js 文件位置在 <code>node_modules/prismjs</code></p><p>prism.css 文件位置在 <code>themes/hexo-theme-matery/source/libs/prism</code></p><p>现在想要去除隔离的那条竖线，尝试重复下面链接的操作，操作过后竖线没有去除，不过稍微调整了一下代码位置，也挺好看</p><p><a href="https://github.com/blinkfox/hexo-theme-matery/issues/103">https://github.com/blinkfox/hexo-theme-matery/issues/103</a></p><p>最终，我通过修改 prism.css 中 border-right 为 0px，去除了行号和代码之间的分隔线！</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.line-numbers .line-numbers-rows</span> <span class="token punctuation">{</span><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token property">pointer-events</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token property">top</span><span class="token punctuation">:</span> -0.2em<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token property">left</span><span class="token punctuation">:</span> -3.8em<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 3em<span class="token punctuation">;</span> <span class="token comment">/* works for line-numbers below 1000 lines */</span><span class="token property">letter-spacing</span><span class="token punctuation">:</span> -1px<span class="token punctuation">;</span><span class="token property">border-right</span><span class="token punctuation">:</span> 0px solid #999<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在解决标号和 code 没对齐的问题，修改 prism.css 文件中 <code>.line-numbers .line-numbers-rows</code> 下 top 参数为 -0.2em，微调成功！治好了强迫症！</p><h2 id="配置-theme-中的-config-yml"><a href="#配置-theme-中的-config-yml" class="headerlink" title="配置 theme 中的 _config.yml"></a>配置 theme 中的 _config.yml</h2><ol><li><p>根据配置文件中的注释，简单修改了下面的设置</p><p>dream, music, video, recommend, github &amp; social link, reward, clicklove, myProjects, mySkills, subtitle, banner</p></li><li><p>取消 rainbow 特效</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.bg-cover:after</span> <span class="token punctuation">{</span>    <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token property">animation</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 hexo d 时遇到问题</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">err: Error: Spawn failed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二天自动好了，根本原因是网络没有走通的问题，之后可能再次遇到，到时候再解决，建议在 github 上搜索</p><p>现在发现了，由于我使用的是 root 用户下的 git 配置，而我 root 用户下 git config 没有设置好参数所以部署失败。我在 root 目录的 .gitconfig 和 .ssh 下配置好了 user.name ssh 等必要 git 配置就成功了。这说明了在 linux 下不同的用户都需要自己去配置 git</p></li><li><p>修改博客 feature image 只选用1张简单图来代表。原来有 24 张图，我把24个路径全部改为同1张图。</p></li><li><p>因为之后需要写入数学公式，将 mathjax 改为 true。但发现显示公式渲染不正常，而且小括号显示不出来。根据 <a href="https://github.com/blinkfox/hexo-theme-matery/issues/119">github issue</a> 解决无法换行问题，将渲染器换为 hexo-renderer-kramed 而且代码高亮插件似乎并没受到影响。根据 <a href="https://adaning.github.io/posts/33457.html">MathJax常见问题</a> 解决小括号无法显示问题。</p></li></ol><h2 id="配置-matery-css"><a href="#配置-matery-css" class="headerlink" title="配置 matery.css"></a>配置 matery.css</h2><p>为了进一步设置我们的网页，让其更具有个性化，就需要进一步调整 matery.css 文件。</p><ol><li><p>设置 导航颜色</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.bg-color</span> <span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #BEBEBE 0%<span class="token punctuation">,</span> #708090 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询颜色代码网址：<a href="https://tool.oschina.net/commons?type=3">https://tool.oschina.net/commons?type=3</a></p></li><li><p>由于刚开始加载时 banner 图片没有迅速加载，会默认先加载橙色，我改成灰色</p><p>修改“\Hexo\themes\hexo-theme-matery\layout\ _partial\index-cover.ejs”文件中的第63行即可。</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>carousel-item red white-text bg-cover about-cover<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把“red”修改为其他颜色即可。我改为 slate gray</p></li><li><p>改变 progress-bar 颜色</p></li><li><p>改变回到顶部按钮颜色 top-scroll</p></li><li><p>改变封面打字效果的文字大小、颜色 .bg-cover .description</p></li><li><p>修改了打字效果的颜色过后，我发现文章标题的颜色也跟着改了。解决方法是在下面的 .bg-cover .description 增加属性 color: #color_code，这样就能分别调整它们的颜色。</p></li><li><p>修改 about 页面链接颜色 aboutme</p></li><li><p>修改 archive 页面时间线颜色 cd-timeline</p></li></ol><h2 id="插件优化"><a href="#插件优化" class="headerlink" title="插件优化"></a>插件优化</h2><h3 id="文章-url-优化"><a href="#文章-url-优化" class="headerlink" title="文章 url 优化"></a>文章 url 优化</h3><p>我没有使用项目中主要介绍的转拼音方法，那样生成的链接太长了，而是使用 hexo-abbrlink 插件</p><pre class="line-numbers language-sehll" data-language="sehll"><code class="language-sehll">npm install hexo-abbrlink --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在根目录 _config.yml 文件中修改</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink</span><span class="token punctuation">:</span> archives/<span class="token punctuation">:</span>abbrlink.html<span class="token key atrule">abbrlink</span><span class="token punctuation">:</span>    <span class="token key atrule">alg</span><span class="token punctuation">:</span> crc32   <span class="token comment">#算法： crc16(default) and crc32</span>    <span class="token key atrule">rep</span><span class="token punctuation">:</span> hex     <span class="token comment">#进制： dec(default) and hex</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 hexo 三连时遇到报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FATAL YAMLException: duplicated mapping key <span class="token punctuation">(</span><span class="token number">111</span>:1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明有原配置文件中已经有 permalink 的定义，我们需要把里本身的 permalink 代码注释掉，完美运行！现在我们的文章 url 最后是特殊的数字id <code>/archives/48732.html</code></p><h3 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h3><h3 id="添加-emoji-表情支持"><a href="#添加-emoji-表情支持" class="headerlink" title="添加 emoji 表情支持"></a>添加 emoji 表情支持</h3><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>上面三个部分都是按照 hexo-thme-matery github 项目配置的</p><h3 id="评论插件utterance"><a href="#评论插件utterance" class="headerlink" title="评论插件utterance"></a>评论插件utterance</h3><p>matery 在配置文件中告诉我们，有的评论软件有安全隐患，推荐使用 utterance</p><p>尝试 utterance，如果成功，则返回卸载 valine，注销 lean cloud</p><p>也尝试了 livere 安装也很不友好</p><p>成功在 contact 页面下展示了 utterance，方法是在 contact.ejs 文档下找了一个地方插入下面的代码（记得改为 r自己的 github repo，形式为 <owner>/<name> ），</name></owner></p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://utteranc.es/client.js<span class="token punctuation">"</span></span><span class="token attr-name">repo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[ENTER REPO HERE]<span class="token punctuation">"</span></span><span class="token attr-name">issue-term</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pathname<span class="token punctuation">"</span></span><span class="token attr-name">theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>github-light<span class="token punctuation">"</span></span><span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anonymous<span class="token punctuation">"</span></span><span class="token attr-name">async</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我插入在 <code>&lt;div class="card"&gt;</code> 后面，是管用的。因为原项目说，插入到你的 layout 需要出现的地方，我不懂前端的代码，只能胡乱插入了，管用就行！我猜测这是一个“卡片类”能够存放你的内容，以白色卡片在页面中展示出来。</p><p>用同样的方法在 post 下添加评论。找到 <code>/hexo-theme-matery/layout/_partial/post-detail.ejs</code> 文件，找到评论的布局之处（搜索主题自带的评论插件如 gittalk，就能找到）插入上面的代码即可。但是渲染过后背景是透明的，不太好看，我希望想 contact 一样有白色背景，那就复制一下 contact.ejs 中的“卡片类”评论区就行了。</p><h3 id="分类优化"><a href="#分类优化" class="headerlink" title="分类优化"></a>分类优化</h3><p>matery 主题的分类没有多层分类，在 categories 页面只有像 tag 一样标签，这样的分类又有什么用呢？根据 <a href="https://notes.zhangxiaocai.cn/posts/5a99eb4d.html#toc-heading-8">Hexo Matery 主题添加多级分类</a> 进行设置，可以得到更好的分类页，类别之间将有层次关系</p><p>具体来讲，采用了博客里最新更新的代码，又作了以下改动：</p><ol><li><p>给 category-item, category-count 等增加 color 属性，改为自己喜欢的颜色</p></li><li><p>给 category-title 增加 font-size 属性，修改标题大小</p></li><li><p>由于每次进入目录默认要展开一个类别，改动下方代码，让所有类别初始状态默认折叠</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">/* origin code: &lt;li  class="&lt;%= subCats.length &gt; 0 ? 'active' : '' %&gt;" &gt; */</span><span class="token operator">&lt;</span>li  <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"&lt;%= subCats.length &gt; 10000 ? 'active' : '' %&gt;"</span> <span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除箭头变化 <code>category-item-action col s11 m11</code></p></li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="网站SEO优化"><a href="#网站SEO优化" class="headerlink" title="网站SEO优化"></a>网站SEO优化</h3><p>Search Engine Optimization</p><p>将自己的网站提交给搜索引擎</p><h3 id="不断更新"><a href="#不断更新" class="headerlink" title="不断更新"></a>不断更新</h3><p>持续更新博客内容，完善分类</p>]]></content>
      
      
      <categories>
          
          <category> 软件基础 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客搭建笔记</title>
      <link href="/archives/4984.html"/>
      <url>/archives/4984.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建-hexo"><a href="#个人博客搭建-hexo" class="headerlink" title="个人博客搭建 hexo"></a>个人博客搭建 hexo</h1><p>整体参考过程为 CodeSheep 视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Node-js-amp-npm"><a href="#Node-js-amp-npm" class="headerlink" title="Node.js &amp; npm"></a>Node.js &amp; npm</h3><p>参考链接：<a href="https://developer.aliyun.com/article/760687">https://developer.aliyun.com/article/760687</a></p><p>我选择了 apt 安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> nodejs <span class="token function">npm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nodejs --versionv10.19.0<span class="token function">npm</span> --version<span class="token number">6.14</span>.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>版本还是有点老旧</p><h3 id="淘宝镜像-cnpm"><a href="#淘宝镜像-cnpm" class="headerlink" title="淘宝镜像 cnpm"></a>淘宝镜像 cnpm</h3><p>cnpm 的官方介绍是：cnpm是一个完整 npmjs.or 镜像，你可以用此代替官方版本(只读)，同步频率目前为 <strong>10分钟</strong> 一次以保证尽量与官方服务同步。</p><p>安装了 cnpm 就可以使用镜像资源下载包，如果不希望使用镜像资源则换回 npm 命令即可。使用如下命令安装</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g cnpm --registry<span class="token operator">=</span>https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> cnpm <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>版本信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo -vhexo-cli: <span class="token number">4.3</span>.0os: linux <span class="token number">5.4</span>.0-77-generic Ubuntu <span class="token number">20.04</span>.2 LTS <span class="token punctuation">(</span>Focal Fossa<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mkdir</span> blog <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> blog<span class="token function">sudo</span> hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果哪里出错了，想重来，直接删除 blog 文件夹即可</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遇到报错</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">INFO  Validating configINFO  Start processingFATAL <span class="token punctuation">{</span> err:   TypeError: line.matchAll is not a <span class="token keyword">function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原因在于 nodejs 版本太低，尝试使用 n 升级 nodejs</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> -g n<span class="token function">sudo</span> n latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看版本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node -vv16.4.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>成功启动 hexo server，你可以通过 <a href="http://localhost:4000">http://localhost:4000</a> 访问你的本地博客啦！</p><h3 id="写第一篇文章"><a href="#写第一篇文章" class="headerlink" title="写第一篇文章"></a>写第一篇文章</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> hexo new <span class="token string">'Fisrt Blog'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">INFO  Validating configINFO  Created: /home/declan/Documents/blog/source/_posts/First-Blog.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你的文章位置在上面的路径中可以找到，可以通过 markdown 语法进行书写</p><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>清理一些缓存，然后生成我们的页面，同样使用 hexo server 从本地查看效果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo cleanhexo generatehexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="布属到远端"><a href="#布属到远端" class="headerlink" title="布属到远端"></a>布属到远端</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>在 github 新建仓库 name.github.io name一定要是你的 github 用户名</p><p>在 blog 目录下，下载 git deployer</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> cnpm <span class="token function">install</span> --save hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置-config-yml"><a href="#设置-config-yml" class="headerlink" title="设置 _config.yml"></a>设置 _config.yml</h3><p>在 blog 目录下打开 _config.yml 文件，在文件最后的 # Deployments 上修改</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># Deployment</span><span class="token comment">## Docs: https://hexo.io/docs/one-command-deployment</span>deploy:  type: <span class="token string">'git'</span>  repo: https://github.com/DeclK/declk.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在你的仓库里多了一些文件</p><p>以后你就可以通过你的仓库名 <em>*</em>.github.io 来访问你的博客啦！</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在寻找了许久过后决定使用 <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件基础 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
